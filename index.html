<!DOCTYPE html>
<html lang="fr" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte Mentale Interactive (Vue.js Avancée)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        :root { font-family: 'Inter', system-ui, Avenir, Helvetica, Arial, sans-serif; }

        #mindMapCanvas { display: block; border-radius: 0.5rem; cursor: grab; }
        #mindMapCanvas:active { cursor: grabbing; }

        #toolbar { border-radius: 0.5rem; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .tool-button, .toolbar-select {
            transition: background-color 0.2s ease-in-out, transform 0.1s ease, color 0.2s ease-in-out;
            display: inline-flex; align-items: center; justify-content: center;
            /* Default padding, height for larger screens */
            height: 2.5rem; padding-left: 0.75rem; padding-right: 0.75rem;
        }
        /* Default width for larger screens */
        .tool-button { width: 2.5rem; }

        /* Mobile specific styles for toolbar buttons */
        @media (max-width: 640px) { /* Corresponds to Tailwind's 'sm' breakpoint */
            .tool-button, .toolbar-select {
                height: 3rem; /* Slightly taller */
                padding-left: 0.875rem; /* p-3.5 */
                padding-right: 0.875rem; /* p-3.5 */
            }
            .tool-button {
                width: 3rem; /* Wider for touch */
            }
        }

        .tool-button:active, .toolbar-select:active { transform: scale(0.95); }

        .toolbar-select {
            background-color: #37474f;
            border-color: #546e7a;
            color: #eceff1;
            min-width: 80px;
        }
        .color-picker-label {
            display: inline-flex; align-items: center; margin-right: 0.5rem;
            padding: 0.25rem 0.5rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.875rem;
            background-color: #37474f;
            color: #cbd5e1;
        }
        .color-picker-input {
            width: 2.5rem; height: 1.5rem; padding: 0.1rem;
            border: 1px solid #4a5568;
            border-radius: 0.25rem; cursor: pointer; vertical-align: middle; margin-left: 0.25rem;
            background-color: #2d3748;
        }

        .modal-backdrop { background-color: rgba(0, 0, 0, 0.6); }
        .modal-content { transform: scale(0.95); opacity: 0; animation: modal-appear 0.3s forwards; }
        @keyframes modal-appear { to { opacity: 1; transform: scale(1); } }

        #contextMenu, #fileContextMenu {
            position: absolute; z-index: 1000;
            border: 1px solid #4a5568;
            border-radius: 0.375rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            min-width: 220px; padding-top: 0.25rem; padding-bottom: 0.25rem;
            background-color: #1e293b;
        }
        .context-menu-item {
            display: block; padding: 0.5rem 1rem; font-size: 0.875rem; cursor: pointer;
            white-space: nowrap; line-height: 1.5;
            color: #e2e8f0;
            transition: background-color 0.1s ease;
        }
        .context-menu-item:hover {
            background-color: #334155;
        }
        .context-menu-item > i:first-child:not(.fa-caret-right):not(.fa-caret-left) { margin-right: 0.6em; width: 1.25em; text-align: center; display: inline-block; vertical-align: middle; }

        /* Mobile specific styles for context menu items */
        @media (max-width: 640px) { /* Corresponds to Tailwind's 'sm' breakpoint */
            .context-menu-item {
                padding: 0.75rem 1.25rem; /* Increased padding: py-3 px-5 */
                font-size: 1rem; /* Increased font size: text-base */
            }
            .submenu-item {
                padding: 0.75rem 1.25rem; /* Increased padding */
                font-size: 1rem; /* Increased font size */
            }
        }

        .context-menu-separator {
            height: 1px; margin-top: 0.25rem; margin-bottom: 0.25rem;
            background-color: #4a5568;
        }
        .context-submenu { position: relative; }
        .submenu-content {
            display: none; position: absolute; left: 100%; top: -5px;
            border: 1px solid #4a5568;
            border-radius: 0.375rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            min-width: 180px; padding-top: 0.25rem; padding-bottom: 0.25rem; z-index: 1001;
            background-color: #1e293b;
        }
        .submenu-content.submenu-left { left: auto; right: 100%; }
        .context-submenu:hover > .submenu-content { display: block; }
        .submenu-item {
            display: block; padding: 0.5rem 1rem; font-size: 0.875rem; cursor: pointer;
            white-space: nowrap; line-height: 1.5;
            color: #e2e8f0;
            transition: background-color 0.1s ease;
        }
        .submenu-item:hover {
            background-color: #334155;
        }
        .submenu-item > i { margin-right: 0.6em; width: 1.25em; text-align: center; display: inline-block; vertical-align: middle; }
        /* Mobile specific styles for submenu items are handled by the .context-menu-item rule via @media query if structure is similar or by direct .submenu-item styling within the media query */
        .submenu-item .link-indicator { display: inline-block; width: 20px; margin-right: 0.5rem; font-family: monospace; text-align: center; vertical-align: middle; }
        .linking-cursor { cursor: crosshair !important; }
        .drag-linking-cursor { cursor: alias !important; }
        [v-cloak] { display: none; }
    </style>
</head>
<body class="dark bg-slate-900 text-gray-200 flex flex-col h-screen overflow-hidden" v-cloak>
    <div id="app" class="flex flex-col h-full">
        <div id="toolbar" class="p-2 m-2 flex items-center space-x-1 sm:space-x-2 flex-wrap bg-slate-800 border border-slate-700 rounded-lg shadow">
            <button @click="toggleFileMenu" ref="fileMenuButton" title="Fichier" class="tool-button bg-sky-600 text-white hover:bg-sky-700 rounded mr-1">
                <i class="fas fa-bars"></i>
            </button>
            <span class="border-r h-6 border-slate-600 hidden sm:inline"></span>

            <button @click="undo" title="Annuler (Ctrl+Z)" :disabled="!canUndo" class="tool-button bg-slate-600 text-gray-200 hover:bg-slate-500 rounded disabled:opacity-50 disabled:cursor-not-allowed"><i class="fas fa-undo"></i></button>
            <button @click="redo" title="Rétablir (Ctrl+Y)" :disabled="!canRedo" class="tool-button bg-slate-600 text-gray-200 hover:bg-slate-500 rounded disabled:opacity-50 disabled:cursor-not-allowed"><i class="fas fa-redo"></i></button>
            <span class="border-r h-6 mx-1 border-slate-600 hidden sm:inline"></span>

            <span class="text-xs text-gray-400 ml-2 mr-1 hidden sm:inline">Alt+Glisser pour lier/créer</span>
            <div class="flex-grow hidden sm:block"></div> <!-- Hide flex-grow on small screens to allow wrapping -->

            <button @click="exportToPng" title="Exporter en PNG" class="tool-button bg-indigo-500 text-white rounded hover:bg-indigo-600"><i class="fas fa-file-export"></i></button>
            <button @click="isAboutModalOpen = true" title="À propos" class="tool-button bg-slate-600 text-gray-200 hover:bg-slate-500 rounded"><i class="fas fa-question-circle"></i></button>
            <span class="border-l h-6 border-slate-600 hidden sm:inline"></span>
            <button @click="toggleSidebar" ref="sidebarToggleButton" title="Propriétés" class="tool-button bg-slate-600 text-gray-200 hover:bg-slate-500 rounded">
                <i class="fas fa-sliders-h"></i>
            </button>

            <input type="file" ref="imageInput" @change="handleImageSelected" accept="image/*" class="hidden">
            <input type="file" ref="mapInput" @change="handleMapFileSelected" accept=".mapvue,application/json" class="hidden">
        </div>

        <div class="flex flex-row flex-1 overflow-hidden m-2 shadow-inner rounded-lg"> {/* New main content wrapper */}
            <div class="flex-grow relative overflow-hidden flex-1"> {/* Canvas container */}
                <canvas ref="mindMapCanvas"
                    id="mindMapCanvas"
                    class="w-full h-full min-w-0" {/* Ensure canvas can shrink */}
                :style="{ backgroundColor: canvasBgColor }"
                :class="{'linking-cursor': isLinking, 'drag-linking-cursor': isDraggingLink}"
                @mousedown="handleMouseDown"
                @mousemove="handleMouseMove"
                @mouseup="handleMouseUp"
                @mouseout="handleMouseOut"
                @dblclick="handleDoubleClick"
                @wheel.prevent="handleWheel"
                @contextmenu.prevent="handleContextMenu">
            </canvas>
        </div>

        <modal :is-open="isTextEditModalOpen" @close="isTextEditModalOpen = false" title="Modifier le texte du nœud">
            <textarea v-model="nodeTextInput" class="w-full p-2 border border-slate-600 rounded mb-4 bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none" rows="3" ref="nodeTextInputArea"></textarea>
            <div class="flex justify-end space-x-2">
                <button @click="isTextEditModalOpen = false" class="px-4 py-2 bg-slate-600 text-gray-200 hover:bg-slate-500 rounded transition-colors">Annuler</button>
                <button @click="saveNodeText" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors">Sauvegarder</button>
            </div>
        </modal>
        <modal :is-open="isHyperlinkModalOpen" @close="isHyperlinkModalOpen = false" title="Ajouter/Modifier un lien hypertexte">
            <input type="url" v-model="hyperlinkInput" placeholder="https://example.com" class="w-full p-2 border border-slate-600 rounded mb-4 bg-slate-700 text-gray-900 dark:text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
            <div class="flex justify-end space-x-2">
                <button @click="isHyperlinkModalOpen = false" class="px-4 py-2 bg-slate-600 text-gray-200 hover:bg-slate-500 rounded transition-colors">Annuler</button>
                <button @click="saveNodeHyperlink" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors">Sauvegarder</button>
            </div>
        </modal>
        <modal :is-open="isImagePreviewModalOpen" @close="isImagePreviewModalOpen = false" title="Aperçu de l'image" width-class="max-w-lg">
            <img :src="previewImageUrl" alt="Aperçu" class="max-w-full max-h-[80vh] block rounded mx-auto">
        </modal>
        <modal :is-open="isDeleteConfirmModalOpen" @close="isDeleteConfirmModalOpen = false" title="Confirmer la suppression">
            <p class="text-gray-300 mb-4">Voulez-vous vraiment supprimer ce nœud et tous ses enfants ? Cette action est irréversible.</p>
            <div class="flex justify-end space-x-2">
                <button @click="isDeleteConfirmModalOpen = false" class="px-4 py-2 bg-slate-600 text-gray-200 hover:bg-slate-500 rounded transition-colors">Annuler</button>
                <button @click="confirmDeleteNode" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors">Supprimer</button>
            </div>
        </modal>
        <modal :is-open="isErrorModalOpen" @close="isErrorModalOpen = false" :title="errorModalTitle">
            <p class="mb-4" :class="errorModalTypeClass">{{ errorModalMessage }}</p>
            <div class="flex justify-end">
                <button @click="isErrorModalOpen = false" class="px-4 py-2 bg-slate-600 text-gray-200 hover:bg-slate-500 rounded transition-colors">Fermer</button>
            </div>
        </modal>
        <modal :is-open="isAboutModalOpen" @close="isAboutModalOpen = false" title="À propos de Carte Mentale Interactive" width-class="max-w-md">
            <p class="text-gray-300 mb-2"><strong>Version :</strong> 1.1.0-alpha</p>
            <p class="text-gray-300 mb-4"><strong>Auteur :</strong> Charles-Antoine Huberdeau</p>
            <div class="border-t border-slate-700 pt-4 mt-4">
                <h4 class="text-md font-semibold mb-2 text-gray-200">Technologies :</h4>
                <ul class="list-disc list-inside text-sm text-gray-400">
                    <li>Vue.js 3</li><li>Tailwind CSS</li><li>Font Awesome</li>
                </ul>
            </div>
            <div class="flex justify-end mt-6">
                <button @click="isAboutModalOpen = false" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors">Fermer</button>
            </div>
        </modal>

        <div v-if="contextMenu.visible" id="contextMenu" ref="contextMenuElement"
            :style="{ top: contextMenu.y + 'px', left: contextMenu.x + 'px' }">
            <template v-if="contextMenu.nodeId && findNodeById(contextMenu.nodeId)">
                <div @click="addNode(contextMenu.nodeId)" class="context-menu-item"><i class="fas fa-plus"></i> Ajouter enfant</div>
                <div @click="openTextEditModal(contextMenu.nodeId)" class="context-menu-item"><i class="fas fa-pencil-alt"></i> Modifier texte</div>
                <div @click="startLinking(contextMenu.nodeId)" class="context-menu-item"><i class="fas fa-people-arrows"></i> Connecter à un autre...</div>
                <template v-if="findNodeById(contextMenu.nodeId).parentId !== null">
                    <div class="context-menu-separator"></div>
                    <div @click="detachNode(contextMenu.nodeId)" class="context-menu-item"><i class="fas fa-unlink"></i> Détacher du parent</div>
                </template>
                <div class="context-menu-separator"></div>
                <div @click="requestDeleteNode(contextMenu.nodeId)" class="context-menu-item text-red-400 hover:bg-red-500 hover:text-white"><i class="fas fa-trash-alt"></i> Supprimer nœud</div>
            </template>
            <template v-else>
                 <div v-if="!hasRootNode" @click="addRootNode(); hideContextMenu();" class="context-menu-item"><i class="fas fa-circle-notch"></i> Créer concept central</div>
                <div @click="addNodeAtPosition(contextMenu.rawX, contextMenu.rawY)" class="context-menu-item"><i class="fas fa-plus-circle"></i> Ajouter nœud ici</div>
                <div class="context-menu-separator"></div>
                <div @click="resetView(); hideContextMenu();" class="context-menu-item"><i class="fas fa-crosshairs"></i> Centrer vue</div>
                <div @click="zoom(1.2); hideContextMenu();" class="context-menu-item"><i class="fas fa-search-plus"></i> Zoom avant</div>
                <div @click="zoom(0.8); hideContextMenu();" class="context-menu-item"><i class="fas fa-search-minus"></i> Zoom arrière</div>
            </template>
        </div>

        <div v-if="fileMenu.visible" id="fileContextMenu" ref="fileMenuElement"
            :style="{ position: 'absolute', top: fileMenu.top, left: fileMenu.left, zIndex: 1000 }">
            <div @click="resetApplication" class="context-menu-item">
                <i class="fas fa-file"></i> Nouveau
            </div>
            <div class="context-menu-separator"></div>
            <div @click="() => { $refs.mapInput.click(); fileMenu.visible = false; }" class="context-menu-item">
                <i class="fas fa-folder-open"></i> Ouvrir un .mapvue
            </div>
            <div @click="() => { saveMapToFile(); fileMenu.visible = false; }" class="context-menu-item">
                <i class="fas fa-file-download"></i> Télécharger (.mapvue)
            </div>
            <div class="context-menu-separator"></div>
            <div class="context-menu-item context-submenu">
                <i class="fas fa-cog"></i> Propriétés <i :class="fileMenuSubmenuOpenLeft ? 'fas fa-caret-left float-right' : 'fas fa-caret-right float-right'"></i>
                <div class="submenu-content" :class="{'submenu-left': fileMenuSubmenuOpenLeft}">
                    <div class="submenu-item flex items-center justify-between px-3 py-2 hover:bg-slate-700" @click.stop>
                        <label for="canvasBgColorPickerMenuFile" class="text-sm text-gray-300 mr-3 whitespace-nowrap cursor-pointer">Fond Canevas:</label>
                        <input type="color" id="canvasBgColorPickerMenuFile"
                               class="color-picker-input h-6 w-10 p-0.5 rounded border-slate-600 bg-slate-700"
                               style="margin-left: 0;"
                               v-model="canvasBgColor">
                    </div>
                </div>
            </div>
            </div>

            <!-- Desktop Sidebar (part of flex flow, shown/hidden by v-if based on !isMobileView && isSidebarOpen) -->
            <div v-if="!isMobileView && isSidebarOpen" id="desktopPropertiesSidebar"
                 class="bg-slate-800 border-l border-slate-700 text-gray-200 flex flex-col"
                 :style="{ width: SIDEBAR_WIDTH_DESKTOP }">
                <div class="p-4 border-b border-slate-700">
                    <h3 class="text-lg font-semibold">Panneau de Contrôle (Desktop)</h3>
                </div>
                <div class="flex-grow p-4 overflow-y-auto">
                    <!-- Canvas Settings Section -->
                    <div class="mb-6 pb-4 border-b border-slate-700">
                        <h4 class="text-md font-semibold mb-3 text-slate-200">Paramètres du Canevas</h4>
                        <div class="mb-4">
                            <label for="canvasBgColorSidebarDesktop" class="block text-sm font-medium text-slate-300 mb-1">Couleur de Fond du Canevas:</label>
                            <input type="color" id="canvasBgColorSidebarDesktop" v-model="canvasBgColor" class="w-full h-8 p-1 border border-slate-600 rounded bg-slate-700 cursor-pointer">
                        </div>
                    </div>
                    <!-- Node Properties Section -->
                    <p v-if="!selectedNode" class="text-slate-400">Sélectionnez un nœud pour voir ses propriétés.</p>
                    <div v-if="selectedNode">
                        <h4 class="text-md font-semibold mb-3 text-slate-200">Propriétés du Nœud</h4>
                        <div class="mb-4">
                            <label class="block text-sm font-medium text-slate-300 mb-1">Texte du Nœud:</label>
                            <p class="p-2 bg-slate-700 rounded text-sm break-all">{{ selectedNode.text }}</p>
                        </div>
                        <div class="mb-4">
                            <label for="nodeBgColorSidebarDesktop" class="block text-sm font-medium text-slate-300 mb-1">Couleur de Fond:</label>
                            <input type="color" id="nodeBgColorSidebarDesktop" :value="selectedNode.color" @input="updateNodeProperty('color', $event.target.value)" class="w-full h-8 p-1 border border-slate-600 rounded bg-slate-700 cursor-pointer">
                        </div>
                        <div class="mb-4">
                            <label for="nodeTextColorSidebarDesktop" class="block text-sm font-medium text-slate-300 mb-1">Couleur du Texte:</label>
                            <input type="color" id="nodeTextColorSidebarDesktop" :value="selectedNode.textColor" @input="updateNodeProperty('textColor', $event.target.value)" class="w-full h-8 p-1 border border-slate-600 rounded bg-slate-700 cursor-pointer">
                        </div>
                        <div class="mb-4">
                            <label for="nodeShapeSidebarDesktop" class="block text-sm font-medium text-slate-300 mb-1">Forme:</label>
                            <select id="nodeShapeSidebarDesktop" :value="selectedNode.shape || NODE_DEFAULT_SHAPE" @change="updateNodeProperty('shape', $event.target.value)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                                <option v-for="shape in NODE_SHAPES" :key="shape" :value="shape">{{ $filters.capitalize(shape) }}</option>
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="nodeIconSidebarDesktop" class="block text-sm font-medium text-slate-300 mb-1">Icône:</label>
                            <select id="nodeIconSidebarDesktop" :value="selectedNode.icon" @change="updateNodeProperty('icon', $event.target.value === 'null' ? null : $event.target.value)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                                <option value="null">Aucune</option>
                                <option v-for="icon in availableIcons" :key="icon.class" :value="icon.class">{{ icon.name }}</option>
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="nodeBorderStyleSidebarDesktop" class="block text-sm font-medium text-slate-300 mb-1">Style de Bordure:</label>
                            <select id="nodeBorderStyleSidebarDesktop" :value="selectedNode.borderStyle || 'solid'" @change="updateNodeProperty('borderStyle', $event.target.value)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                                <option v-for="style in availableBorderStyles" :key="style.value" :value="style.value">{{ style.name }}</option>
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="nodeBorderWidthSidebarDesktop" class="block text-sm font-medium text-slate-300 mb-1">Épaisseur de Bordure (px):</label>
                            <select id="nodeBorderWidthSidebarDesktop" :value="selectedNode.borderWidth || 1" @change="updateNodeProperty('borderWidth', parseInt($event.target.value))" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                                <option v-for="width in [1, 2, 3, 4, 5]" :key="width" :value="width">{{ width }}px</option>
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="nodeFontSizeSidebarDesktop" class="block text-sm font-medium text-slate-300 mb-1">Taille Police (px):</label>
                            <input type="number" id="nodeFontSizeSidebarDesktop" :value="selectedNode.fontSize || NODE_DEFAULT_FONT_SIZE" @input="updateNodeProperty('fontSize', parseInt($event.target.value) || NODE_DEFAULT_FONT_SIZE)" min="8" max="72" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                        </div>
                        <div class="mb-4">
                            <label for="nodeFontFamilySidebarDesktop" class="block text-sm font-medium text-slate-300 mb-1">Police:</label>
                            <select id="nodeFontFamilySidebarDesktop" :value="selectedNode.fontFamily || NODE_DEFAULT_FONT_FAMILY" @change="updateNodeProperty('fontFamily', $event.target.value || NODE_DEFAULT_FONT_FAMILY)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                                <option v-for="font in AVAILABLE_FONT_FAMILIES" :key="font.value" :value="font.value">{{ font.name }}</option>
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="nodePaddingSidebarDesktop" class="block text-sm font-medium text-slate-300 mb-1">Marge Interne (px):</label>
                            <input type="number" id="nodePaddingSidebarDesktop" :value="selectedNode.padding === undefined ? NODE_DEFAULT_PADDING : selectedNode.padding" @input="updateNodePadding(parseInt($event.target.value))" min="0" max="50" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                        </div>

                        <!-- Node Gradient Section -->
                        <div class="mt-4 pt-4 border-t border-slate-600">
                            <h5 class="text-sm font-semibold mb-2 text-slate-300">Fond en Dégradé</h5>
                            <div class="mb-2">
                                <label class="flex items-center space-x-2 cursor-pointer">
                                    <input type="checkbox" :checked="selectedNode.bgGradientEnabled === undefined ? NODE_DEFAULT_GRADIENT_ENABLED : selectedNode.bgGradientEnabled" @change="updateNodeProperty('bgGradientEnabled', $event.target.checked)" class="form-checkbox h-5 w-5 text-blue-600 bg-slate-700 border-slate-500 rounded focus:ring-blue-500">
                                    <span class="text-sm text-slate-300">Activer Dégradé</span>
                                </label>
                            </div>
                            <div class="mb-2">
                                <label for="nodeGradientColor1Desktop" class="block text-xs font-medium text-slate-400 mb-1">Couleur 1 Dégradé:</label>
                                <input type="color" id="nodeGradientColor1Desktop" :value="selectedNode.bgColor1 || NODE_DEFAULT_GRADIENT_COLOR1" @input="updateNodeProperty('bgColor1', $event.target.value)" class="w-full h-8 p-1 border border-slate-600 rounded bg-slate-700 cursor-pointer" :disabled="!(selectedNode.bgGradientEnabled === undefined ? NODE_DEFAULT_GRADIENT_ENABLED : selectedNode.bgGradientEnabled)">
                            </div>
                            <div class="mb-2">
                                <label for="nodeGradientColor2Desktop" class="block text-xs font-medium text-slate-400 mb-1">Couleur 2 Dégradé:</label>
                                <input type="color" id="nodeGradientColor2Desktop" :value="selectedNode.bgColor2 || NODE_DEFAULT_GRADIENT_COLOR2" @input="updateNodeProperty('bgColor2', $event.target.value)" class="w-full h-8 p-1 border border-slate-600 rounded bg-slate-700 cursor-pointer" :disabled="!(selectedNode.bgGradientEnabled === undefined ? NODE_DEFAULT_GRADIENT_ENABLED : selectedNode.bgGradientEnabled)">
                            </div>
                            <div class="mb-2">
                                <label for="nodeGradientDirectionDesktop" class="block text-xs font-medium text-slate-400 mb-1">Direction Dégradé:</label>
                                <select id="nodeGradientDirectionDesktop" :value="selectedNode.gradientDirection || NODE_DEFAULT_GRADIENT_DIRECTION" @change="updateNodeProperty('gradientDirection', $event.target.value)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none" :disabled="!(selectedNode.bgGradientEnabled === undefined ? NODE_DEFAULT_GRADIENT_ENABLED : selectedNode.bgGradientEnabled)">
                                    <option v-for="dir in AVAILABLE_GRADIENT_DIRECTIONS" :key="dir.value" :value="dir.value">{{ dir.name }}</option>
                                </select>
                            </div>
                        </div>

                        <!-- Node Shadow Section -->
                        <div class="mt-4 pt-4 border-t border-slate-600">
                            <h5 class="text-sm font-semibold mb-2 text-slate-300">Ombre du Nœud</h5>
                            <div class="mb-2">
                                <label class="flex items-center space-x-2 cursor-pointer">
                                    <input type="checkbox" :checked="selectedNode.shadowEnabled === undefined ? NODE_DEFAULT_SHADOW_ENABLED : selectedNode.shadowEnabled" @change="updateNodeProperty('shadowEnabled', $event.target.checked)" class="form-checkbox h-5 w-5 text-blue-600 bg-slate-700 border-slate-500 rounded focus:ring-blue-500">
                                    <span class="text-sm text-slate-300">Activer Ombre</span>
                                </label>
                            </div>
                            <div class="mb-2">
                                <label for="nodeShadowColorDesktop" class="block text-xs font-medium text-slate-400 mb-1">Couleur Ombre:</label>
                                <input type="color" id="nodeShadowColorDesktop" :value="selectedNode.shadowColor || NODE_DEFAULT_SHADOW_COLOR" @input="updateNodeProperty('shadowColor', $event.target.value)" class="w-full h-8 p-1 border border-slate-600 rounded bg-slate-700 cursor-pointer" :disabled="!(selectedNode.shadowEnabled === undefined ? NODE_DEFAULT_SHADOW_ENABLED : selectedNode.shadowEnabled)">
                            </div>
                            <div class="mb-2">
                                <label for="nodeShadowBlurDesktop" class="block text-xs font-medium text-slate-400 mb-1">Flou Ombre (px):</label>
                                <input type="number" id="nodeShadowBlurDesktop" :value="selectedNode.shadowBlur === undefined ? NODE_DEFAULT_SHADOW_BLUR : selectedNode.shadowBlur" @input="updateNodeProperty('shadowBlur', parseInt($event.target.value) || 0)" min="0" max="50" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none" :disabled="!(selectedNode.shadowEnabled === undefined ? NODE_DEFAULT_SHADOW_ENABLED : selectedNode.shadowEnabled)">
                            </div>
                            <div class="grid grid-cols-2 gap-2 mb-2">
                                <div>
                                    <label for="nodeShadowOffsetXDesktop" class="block text-xs font-medium text-slate-400 mb-1">Décalage X (px):</label>
                                    <input type="number" id="nodeShadowOffsetXDesktop" :value="selectedNode.shadowOffsetX === undefined ? NODE_DEFAULT_SHADOW_OFFSET_X : selectedNode.shadowOffsetX" @input="updateNodeProperty('shadowOffsetX', parseInt($event.target.value) || 0)" min="-50" max="50" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none" :disabled="!(selectedNode.shadowEnabled === undefined ? NODE_DEFAULT_SHADOW_ENABLED : selectedNode.shadowEnabled)">
                                </div>
                                <div>
                                    <label for="nodeShadowOffsetYDesktop" class="block text-xs font-medium text-slate-400 mb-1">Décalage Y (px):</label>
                                    <input type="number" id="nodeShadowOffsetYDesktop" :value="selectedNode.shadowOffsetY === undefined ? NODE_DEFAULT_SHADOW_OFFSET_Y : selectedNode.shadowOffsetY" @input="updateNodeProperty('shadowOffsetY', parseInt($event.target.value) || 0)" min="-50" max="50" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none" :disabled="!(selectedNode.shadowEnabled === undefined ? NODE_DEFAULT_SHADOW_ENABLED : selectedNode.shadowEnabled)">
                                </div>
                            </div>
                        </div>


                        <!-- Node Shadow Section - Mobile -->
                        <div class="mt-4 pt-4 border-t border-slate-600">
                            <h5 class="text-sm font-semibold mb-2 text-slate-300">Ombre du Nœud</h5>
                            <div class="mb-2">
                                <label class="flex items-center space-x-2 cursor-pointer">
                                    <input type="checkbox" :checked="selectedNode.shadowEnabled === undefined ? NODE_DEFAULT_SHADOW_ENABLED : selectedNode.shadowEnabled" @change="updateNodeProperty('shadowEnabled', $event.target.checked)" class="form-checkbox h-5 w-5 text-blue-600 bg-slate-700 border-slate-500 rounded focus:ring-blue-500">
                                    <span class="text-sm text-slate-300">Activer Ombre</span>
                                </label>
                            </div>
                            <div class="mb-2">
                                <label for="nodeShadowColorMobile" class="block text-xs font-medium text-slate-400 mb-1">Couleur Ombre:</label>
                                <input type="color" id="nodeShadowColorMobile" :value="selectedNode.shadowColor || NODE_DEFAULT_SHADOW_COLOR" @input="updateNodeProperty('shadowColor', $event.target.value)" class="w-full h-8 p-1 border border-slate-600 rounded bg-slate-700 cursor-pointer" :disabled="!(selectedNode.shadowEnabled === undefined ? NODE_DEFAULT_SHADOW_ENABLED : selectedNode.shadowEnabled)">
                            </div>
                            <div class="mb-2">
                                <label for="nodeShadowBlurMobile" class="block text-xs font-medium text-slate-400 mb-1">Flou Ombre (px):</label>
                                <input type="number" id="nodeShadowBlurMobile" :value="selectedNode.shadowBlur === undefined ? NODE_DEFAULT_SHADOW_BLUR : selectedNode.shadowBlur" @input="updateNodeProperty('shadowBlur', parseInt($event.target.value) || 0)" min="0" max="50" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none" :disabled="!(selectedNode.shadowEnabled === undefined ? NODE_DEFAULT_SHADOW_ENABLED : selectedNode.shadowEnabled)">
                            </div>
                            <div class="grid grid-cols-2 gap-2 mb-2">
                                <div>
                                    <label for="nodeShadowOffsetXMobile" class="block text-xs font-medium text-slate-400 mb-1">Décalage X (px):</label>
                                    <input type="number" id="nodeShadowOffsetXMobile" :value="selectedNode.shadowOffsetX === undefined ? NODE_DEFAULT_SHADOW_OFFSET_X : selectedNode.shadowOffsetX" @input="updateNodeProperty('shadowOffsetX', parseInt($event.target.value) || 0)" min="-50" max="50" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none" :disabled="!(selectedNode.shadowEnabled === undefined ? NODE_DEFAULT_SHADOW_ENABLED : selectedNode.shadowEnabled)">
                                </div>
                                <div>
                                    <label for="nodeShadowOffsetYMobile" class="block text-xs font-medium text-slate-400 mb-1">Décalage Y (px):</label>
                                    <input type="number" id="nodeShadowOffsetYMobile" :value="selectedNode.shadowOffsetY === undefined ? NODE_DEFAULT_SHADOW_OFFSET_Y : selectedNode.shadowOffsetY" @input="updateNodeProperty('shadowOffsetY', parseInt($event.target.value) || 0)" min="-50" max="50" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none" :disabled="!(selectedNode.shadowEnabled === undefined ? NODE_DEFAULT_SHADOW_ENABLED : selectedNode.shadowEnabled)">
                                </div>
                            </div>
                        </div>

                        <div class="mt-4 pt-4 border-t border-slate-600">
                            <button @click="triggerImageUpload(selectedNodeId)" class="w-full mb-2 px-4 py-2 text-sm text-white rounded transition-colors" :class="selectedNode.imageUrl ? 'bg-amber-600 hover:bg-amber-700' : 'bg-sky-600 hover:bg-sky-700'">
                                <i class="fas fa-image mr-2"></i> {{ selectedNode.imageUrl ? 'Modifier Image' : 'Ajouter Image...' }}
                            </button>
                            <button @click="openHyperlinkModal(selectedNodeId)" class="w-full px-4 py-2 text-sm text-white rounded transition-colors" :class="selectedNode.hyperlink ? 'bg-amber-600 hover:bg-amber-700' : 'bg-sky-600 hover:bg-sky-700'">
                                <i class="fas fa-link mr-2"></i> {{ selectedNode.hyperlink ? 'Modifier Lien' : 'Ajouter Lien...' }}
                            </button>
                        </div>
                        <div class="mt-4 pt-4 border-t border-slate-600">
                            <label class="block text-sm font-medium text-slate-300 mb-2">Image de Fond du Nœud:</label>
                            <input type="file" ref="nodeBgImageInputDesktop" @change="handleNodeBgImageSelected" accept="image/*" class="hidden">
                            <button @click="$refs.nodeBgImageInputDesktop.click()" class="w-full mb-2 px-4 py-2 text-sm bg-teal-600 hover:bg-teal-700 text-white rounded transition-colors">
                                <i class="fas fa-photo-video mr-2"></i> Choisir Image de Fond...
                            </button>
                            <button v-if="selectedNode.nodeBgImageUrl" @click="removeNodeBgImage(selectedNodeId)" class="w-full px-4 py-2 text-sm bg-red-600 hover:bg-red-700 text-white rounded transition-colors">
                                <i class="fas fa-trash mr-2"></i> Supprimer Image de Fond
                            </button>
                        </div>
                    </div>
                    <div v-if="selectedNode && selectedNode.parentId !== null" class="mt-6 pt-4 border-t border-slate-700">
                        <h4 class="text-md font-semibold mb-2 text-slate-200">Propriétés de Connexion (au parent)</h4>
                        <div class="mb-4">
                            <label for="nodeEntryPointSidebarDesktop" class="block text-sm font-medium text-slate-300 mb-1">Point d'Entrée (sur ce nœud):</label>
                            <select id="nodeEntryPointSidebarDesktop" :value="selectedNode.entryPoint || 'auto'" @change="setNodeProperty(selectedNodeId, 'entryPoint', $event.target.value)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                                <option v-for="point in ['auto', ...CONNECTION_POINTS]" :key="'entry-'+point" :value="point">{{ $filters.capitalize(point) }}</option>
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="nodeParentExitPointSidebarDesktop" class="block text-sm font-medium text-slate-300 mb-1">Point de Sortie (sur parent):</label>
                            <select id="nodeParentExitPointSidebarDesktop" :value="selectedNode.parentExitPoint || 'auto'" @change="setNodeProperty(selectedNodeId, 'parentExitPoint', $event.target.value)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                                <option v-for="point in ['auto', ...CONNECTION_POINTS]" :key="'exit-'+point" :value="point">{{ $filters.capitalize(point) }}</option>
                            </select>
                        </div>
                        <div class="mb-4">
                            <label for="nodeConnectionTypeSidebarDesktop" class="block text-sm font-medium text-slate-300 mb-1">Type de Ligne:</label>
                            <select id="nodeConnectionTypeSidebarDesktop" :value="selectedNode.connectionType || 'solid'" @change="setNodeProperty(selectedNodeId, 'connectionType', $event.target.value)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                                <option v-for="type in CONNECTION_TYPES" :key="type" :value="type">
                                    <span class="link-indicator">{{ getConnectionTypeIndicator(type) }}</span> {{ $filters.capitalize(type) }}
                                </option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mobile Overlay Sidebar (absolute/fixed positioning, shown/hidden by v-if and transform) -->
        <div v-if="isMobileView && isSidebarOpen" id="mobilePropertiesSidebar"
             class="bg-slate-800 border-l border-slate-700 text-gray-200 flex flex-col fixed inset-y-0 right-0 h-full shadow-lg transition-transform duration-300 ease-in-out transform"
             :class="isSidebarOpen ? 'translate-x-0' : 'translate-x-full'"
             :style="{ width: '80%', zIndex: 1002 }">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center">
                <h3 class="text-lg font-semibold">Panneau de Contrôle</h3>
                <button @click="toggleSidebar" class="text-gray-400 hover:text-gray-200 sm:hidden" aria-label="Close sidebar">
                    <i class="fas fa-times"></i>
                </button>
            </div>
             <div class="flex-grow p-4 overflow-y-auto">
                <!-- Canvas Settings Section -->
                <div class="mb-6 pb-4 border-b border-slate-700">
                    <h4 class="text-md font-semibold mb-3 text-slate-200">Paramètres du Canevas</h4>
                    <div class="mb-4">
                        <label for="canvasBgColorSidebar" class="block text-sm font-medium text-slate-300 mb-1">Couleur de Fond du Canevas:</label>
                        <input type="color" id="canvasBgColorSidebar" v-model="canvasBgColor" class="w-full h-8 p-1 border border-slate-600 rounded bg-slate-700 cursor-pointer">
                    </div>
                </div>

                <!-- Node Properties Section -->
                <p v-if="!selectedNode" class="text-slate-400">Sélectionnez un nœud pour voir ses propriétés.</p>
                <div v-if="selectedNode">
                    <h4 class="text-md font-semibold mb-3 text-slate-200">Propriétés du Nœud</h4>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-slate-300 mb-1">Texte du Nœud:</label>
                        <p class="p-2 bg-slate-700 rounded text-sm break-all">{{ selectedNode.text }}</p>
                    </div>
                    <div class="mb-4">
                        <label for="nodeBgColorSidebar" class="block text-sm font-medium text-slate-300 mb-1">Couleur de Fond:</label>
                        <input type="color" id="nodeBgColorSidebar" :value="selectedNode.color" @input="updateNodeProperty('color', $event.target.value)" class="w-full h-8 p-1 border border-slate-600 rounded bg-slate-700 cursor-pointer">
                    </div>
                    <div class="mb-4">
                        <label for="nodeTextColorSidebar" class="block text-sm font-medium text-slate-300 mb-1">Couleur du Texte:</label>
                        <input type="color" id="nodeTextColorSidebar" :value="selectedNode.textColor" @input="updateNodeProperty('textColor', $event.target.value)" class="w-full h-8 p-1 border border-slate-600 rounded bg-slate-700 cursor-pointer">
                    </div>
                    <div class="mb-4">
                        <label for="nodeShapeSidebar" class="block text-sm font-medium text-slate-300 mb-1">Forme:</label>
                        <select id="nodeShapeSidebar" :value="selectedNode.shape || NODE_DEFAULT_SHAPE" @change="updateNodeProperty('shape', $event.target.value)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                            <option v-for="shape in NODE_SHAPES" :key="shape" :value="shape">{{ $filters.capitalize(shape) }}</option>
                        </select>
                    </div>
                    <div class="mb-4">
                        <label for="nodeIconSidebar" class="block text-sm font-medium text-slate-300 mb-1">Icône:</label>
                        <select id="nodeIconSidebar" :value="selectedNode.icon" @change="updateNodeProperty('icon', $event.target.value === 'null' ? null : $event.target.value)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                            <option value="null">Aucune</option>
                            <option v-for="icon in availableIcons" :key="icon.class" :value="icon.class">{{ icon.name }}</option>
                        </select>
                    </div>
                    <div class="mb-4">
                        <label for="nodeBorderStyleSidebar" class="block text-sm font-medium text-slate-300 mb-1">Style de Bordure:</label>
                        <select id="nodeBorderStyleSidebar" :value="selectedNode.borderStyle || 'solid'" @change="updateNodeProperty('borderStyle', $event.target.value)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                            <option v-for="style in availableBorderStyles" :key="style.value" :value="style.value">{{ style.name }}</option>
                        </select>
                    </div>
                    <div class="mb-4">
                        <label for="nodeBorderWidthSidebar" class="block text-sm font-medium text-slate-300 mb-1">Épaisseur de Bordure (px):</label>
                        <select id="nodeBorderWidthSidebar" :value="selectedNode.borderWidth || 1" @change="updateNodeProperty('borderWidth', parseInt($event.target.value))" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                            <option v-for="width in [1, 2, 3, 4, 5]" :key="width" :value="width">{{ width }}px</option>
                        </select>
                    </div>

                    <div class="mt-4 pt-4 border-t border-slate-600">
                        <button @click="triggerImageUpload(selectedNodeId)" class="w-full mb-2 px-4 py-2 text-sm text-white rounded transition-colors" :class="selectedNode.imageUrl ? 'bg-amber-600 hover:bg-amber-700' : 'bg-sky-600 hover:bg-sky-700'">
                            <i class="fas fa-image mr-2"></i> {{ selectedNode.imageUrl ? 'Modifier Image' : 'Ajouter Image...' }}
                        </button>
                        <button @click="openHyperlinkModal(selectedNodeId)" class="w-full px-4 py-2 text-sm text-white rounded transition-colors" :class="selectedNode.hyperlink ? 'bg-amber-600 hover:bg-amber-700' : 'bg-sky-600 hover:bg-sky-700'">
                            <i class="fas fa-link mr-2"></i> {{ selectedNode.hyperlink ? 'Modifier Lien' : 'Ajouter Lien...' }}
                        </button>
                    </div>

                    <div class="mt-4 pt-4 border-t border-slate-600">
                        <label class="block text-sm font-medium text-slate-300 mb-2">Image de Fond du Nœud:</label>
                        <input type="file" ref="nodeBgImageInput" @change="handleNodeBgImageSelected" accept="image/*" class="hidden">
                        <button @click="$refs.nodeBgImageInput.click()" class="w-full mb-2 px-4 py-2 text-sm bg-teal-600 hover:bg-teal-700 text-white rounded transition-colors">
                            <i class="fas fa-photo-video mr-2"></i> Choisir Image de Fond...
                        </button>
                        <button v-if="selectedNode.nodeBgImageUrl" @click="removeNodeBgImage(selectedNodeId)" class="w-full px-4 py-2 text-sm bg-red-600 hover:bg-red-700 text-white rounded transition-colors">
                            <i class="fas fa-trash mr-2"></i> Supprimer Image de Fond
                        </button>
                    </div>
                </div>

                <!-- Connection Properties Section (only if node has a parent) -->
                <div v-if="selectedNode && selectedNode.parentId !== null" class="mt-6 pt-4 border-t border-slate-700">
                    <h4 class="text-md font-semibold mb-2 text-slate-200">Propriétés de Connexion (au parent)</h4>
                    <div class="mb-4">
                        <label for="nodeEntryPointSidebar" class="block text-sm font-medium text-slate-300 mb-1">Point d'Entrée (sur ce nœud):</label>
                        <select id="nodeEntryPointSidebar" :value="selectedNode.entryPoint || 'auto'" @change="setNodeProperty(selectedNodeId, 'entryPoint', $event.target.value)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                            <option v-for="point in ['auto', ...CONNECTION_POINTS]" :key="'entry-'+point" :value="point">{{ $filters.capitalize(point) }}</option>
                        </select>
                    </div>
                    <div class="mb-4">
                        <label for="nodeParentExitPointSidebar" class="block text-sm font-medium text-slate-300 mb-1">Point de Sortie (sur parent):</label>
                        <select id="nodeParentExitPointSidebar" :value="selectedNode.parentExitPoint || 'auto'" @change="setNodeProperty(selectedNodeId, 'parentExitPoint', $event.target.value)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                            <option v-for="point in ['auto', ...CONNECTION_POINTS]" :key="'exit-'+point" :value="point">{{ $filters.capitalize(point) }}</option>
                        </select>
                    </div>
                    <div class="mb-4">
                        <label for="nodeConnectionTypeSidebar" class="block text-sm font-medium text-slate-300 mb-1">Type de Ligne:</label>
                        <select id="nodeConnectionTypeSidebar" :value="selectedNode.connectionType || 'solid'" @change="setNodeProperty(selectedNodeId, 'connectionType', $event.target.value)" class="w-full p-2 border border-slate-600 rounded bg-slate-700 text-gray-200 focus:ring-2 focus:ring-blue-500 outline-none">
                            <option v-for="type in CONNECTION_TYPES" :key="type" :value="type">
                                <span class="link-indicator">{{ getConnectionTypeIndicator(type) }}</span> {{ $filters.capitalize(type) }}
                            </option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const NODE_DEFAULT_WIDTH = 120; const NODE_DEFAULT_HEIGHT = 40;
        const NODE_DEFAULT_BG_COLOR = '#ffffff'; const NODE_DEFAULT_TEXT_COLOR = '#1f2937'; // Used if node.color/textColor is null
        const NODE_SELECTED_BORDER_COLOR = '#3b82f6'; const NODE_DROP_TARGET_BORDER_COLOR = '#10b981';
        const NODE_LINK_TARGET_BORDER_COLOR = '#f59e0b'; const CONNECTION_HOVER_COLOR = '#3b82f6';
        const CONNECTION_PREVIEW_COLOR = '#facc15';
        const IMAGE_INDICATOR_SIZE = 15; const IMAGE_INDICATOR_COLOR = '#10b981';
        const CONNECTION_TYPES = ['solid', 'dashed', 'arrow']; const CONNECTION_POINTS = ['auto', 'top', 'bottom', 'left', 'right'];
        const REPARENT_PROXIMITY_THRESHOLD = 60; const CONNECTION_END_HOVER_RADIUS = 8;
        const NODE_SHAPES = ['rectangle', 'ellipse', 'diamond', 'triangle']; const NODE_DEFAULT_SHAPE = 'rectangle';
        const NODE_APPEAR_SPEED = 0.07; const NODE_HOVER_SCALE = 1.05;
        const MAX_HISTORY_STATES = 50;
        const LINK_ANIMATION_DURATION = 200;
        const TEMP_LINK_COLOR = '#818cf8';
        const AUTOSAVE_INTERVAL = 50000;
        const DEFAULT_CANVAS_BG_COLOR = '#2d3748';
        const CHILD_NODE_SPACING = 40; // Increased spacing

        const SIDEBAR_WIDTH_DESKTOP = '320px';
        const MIN_NODE_WIDTH = 80;
        const MAX_NODE_WIDTH = 500;
        const MIN_NODE_HEIGHT = 40;
        const MAX_NODE_HEIGHT = 300;

        const NODE_DEFAULT_FONT_SIZE = 14;
        const NODE_DEFAULT_FONT_FAMILY = 'Inter, sans-serif'; // Default stack
        const NODE_DEFAULT_PADDING = 10;
        const NODE_TEXT_LINE_HEIGHT_RATIO = 1.2;

        const NODE_DEFAULT_SHADOW_ENABLED = true;
        const NODE_DEFAULT_SHADOW_COLOR = 'rgba(0,0,0,0.4)';
        const NODE_DEFAULT_SHADOW_BLUR = 5;
        const NODE_DEFAULT_SHADOW_OFFSET_X = 2;
        const NODE_DEFAULT_SHADOW_OFFSET_Y = 2;

        const NODE_DEFAULT_GRADIENT_ENABLED = false;
        const NODE_DEFAULT_GRADIENT_COLOR1 = '#FFFFFF';
        const NODE_DEFAULT_GRADIENT_COLOR2 = '#DDDDDD';
        const NODE_DEFAULT_GRADIENT_DIRECTION = 'vertical';
        const AVAILABLE_GRADIENT_DIRECTIONS = [
            { name: 'Vertical (Haut → Bas)', value: 'vertical' },
            { name: 'Horizontal (Gauche → Droite)', value: 'horizontal' },
            { name: 'Diagonal (Haut-Gauche → Bas-Droite)', value: 'diagonal1' },
            { name: 'Diagonal (Haut-Droite → Bas-Gauche)', value: 'diagonal2' }
        ];

        const AVAILABLE_FONT_FAMILIES = [
            { name: 'Inter', value: 'Inter, sans-serif' },
            { name: 'Arial', value: 'Arial, sans-serif' },
            { name: 'Verdana', value: 'Verdana, sans-serif' },
            { name: 'Georgia', value: 'Georgia, serif' },
            { name: 'Times New Roman', value: 'Times New Roman, Times, serif' }
        ];


        const AVAILABLE_ICONS = [
            { name: 'Ampoule', class: 'fas fa-lightbulb', unicode: '\uf0eb' }, { name: 'Étoile', class: 'fas fa-star', unicode: '\uf005' },
            { name: 'Coche', class: 'fas fa-check', unicode: '\uf00c' }, { name: 'Question', class: 'fas fa-question-circle', unicode: '\uf059' },
            { name: 'Attention', class: 'fas fa-exclamation-triangle', unicode: '\uf071' }, { name: 'Info', class: 'fas fa-info-circle', unicode: '\uf05a' },
            { name: 'Lien', class: 'fas fa-link', unicode: '\uf0c1' }, { name: 'Dossier', class: 'fas fa-folder', unicode: '\uf07b' },
            { name: 'Personne', class: 'fas fa-user', unicode: '\uf007' },
        ];
        const HYPERLINK_INDICATOR_UNICODE = '\uf0c1';
        const ICON_SIZE = 16;

        const AVAILABLE_BORDER_STYLES = [
            { name: 'Solide', value: 'solid', dash: [] }, { name: 'Tiretée', value: 'dashed', dash: [7, 4] },
            { name: 'Pointillée', value: 'dotted', dash: [2, 3] },
        ];

        const generateUUID = () => (typeof crypto !== 'undefined' && crypto.randomUUID) ? crypto.randomUUID() : (Date.now().toString(36) + Math.random().toString(36).substring(2));
        const getDynamicDrawingStyles = () => ({
            connectionColor: '#718096',
            nodeDefaultBorderColor: '#A0AEC0',
            shadowColor: 'rgba(0,0,0,0.4)',
            contextMenuBg: 'bg-slate-800',
            contextMenuItemText: 'text-gray-200',
            contextMenuItemHoverBg: 'hover:bg-slate-700',
            contextMenuBorder: 'border-slate-700',
        });

        const fillRoundRect = (ctx, x, y, w, h, r) => { if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2; ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath(); ctx.fill(); };
        const strokeRoundRect = (ctx, x, y, w, h, r) => { if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2; ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath(); ctx.stroke(); };

        const drawNodeBackgroundPattern = (ctx, node, img) => {
            // General "cover" logic for node background image
            if (!img || !img.complete || img.naturalWidth === 0) return false; // Don't draw if image not loaded or invalid

            const nodeWidth = node.width;
            const nodeHeight = node.height;
            const imgWidth = img.naturalWidth;
            const imgHeight = img.naturalHeight;

            const nodeAspectRatio = nodeWidth / nodeHeight;
            const imgAspectRatio = imgWidth / imgHeight;

            let sx, sy, sWidth, sHeight;

            if (imgAspectRatio > nodeAspectRatio) { // Image is wider than node shape, crop image width
                sHeight = imgHeight;
                sWidth = imgHeight * nodeAspectRatio;
                sx = (imgWidth - sWidth) / 2;
                sy = 0;
            } else { // Image is taller than node shape (or same aspect ratio), crop image height
                sWidth = imgWidth;
                sHeight = imgWidth / nodeAspectRatio;
                sx = 0;
                sy = (imgHeight - sHeight) / 2;
            }
            // Clip to the node's path before drawing the image
            // The path is already set by the calling drawXXXNode function.
            ctx.save();
            ctx.clip();
            ctx.drawImage(img, sx, sy, sWidth, sHeight, node.x, node.y, nodeWidth, node.height);
            ctx.restore();
            return true; // Indicates image was drawn
        };

        const wrapText = (context, node) => {
            const textToWrap = node.text || "";
            const currentPadding = node.padding === undefined ? NODE_DEFAULT_PADDING : node.padding;
            const currentFontSize = node.fontSize || NODE_DEFAULT_FONT_SIZE;
            const currentFontFamily = node.fontFamily || NODE_DEFAULT_FONT_FAMILY;
            const lineHeight = currentFontSize * NODE_TEXT_LINE_HEIGHT_RATIO;

            context.font = `${currentFontSize}px ${currentFontFamily}`;

            let iconOffsetLeft = 0; const iconInternalPadding = 5;
            if (node.icon) iconOffsetLeft += ICON_SIZE + iconInternalPadding;
            if (node.hyperlink) iconOffsetLeft += ICON_SIZE + iconInternalPadding;

            // availableTextWidth is the space for text, between paddings and after icons.
            const availableTextWidth = node.width - (currentPadding * 2) - iconOffsetLeft;

            // actualTextDrawX is the x-coordinate for canvas text drawing (which centers the text)
            // It starts from node.x, adds left padding, adds space for icons, then half of the text's available width.
            const actualTextDrawX = node.x + currentPadding + iconOffsetLeft + (availableTextWidth / 2);

            const lines = String(textToWrap).split('\n');
            const processedLines = [];
            lines.forEach(lineText => {
                const words = lineText.split(' ');
                let currentLine = '';
                for (let n = 0; n < words.length; n++) {
                    let testLine = currentLine + words[n] + ' ';
                    let metrics = context.measureText(testLine);
                    let testWidth = metrics.width;
                    if (testWidth > availableTextWidth && n > 0) {
                        processedLines.push(currentLine.trim());
                        currentLine = words[n] + ' ';
                    } else {
                        currentLine = testLine;
                    }
                }
                processedLines.push(currentLine.trim());
            });

            const numberOfLines = processedLines.length || 1;
            const textBlockHeight = numberOfLines * lineHeight;

            // Calculate Y position for the top of the text block, centering it vertically within the padded area
            const textBlockTopY = node.y + currentPadding + ((node.height - (currentPadding * 2) - textBlockHeight) / 2);

            context.textAlign = 'center'; // Ensure text alignment is centered for actualTextDrawX
            context.textBaseline = 'middle'; // Align text vertically by its middle

            processedLines.forEach((line, index) => {
                context.fillText(line, actualTextDrawX, textBlockTopY + (index * lineHeight) + (lineHeight / 2));
            });
        };
        const drawArrowhead = (context, fromX, fromY, toX, toY, headLength) => { const dx = toX - fromX; const dy = toY - fromY; const angle = Math.atan2(dy, dx); context.beginPath(); context.moveTo(toX, toY); context.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), toY - headLength * Math.sin(angle - Math.PI / 6)); context.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), toY - headLength * Math.sin(angle + Math.PI / 6)); context.closePath(); context.fill(); };

        const drawRectangleNode = (ctx, node) => {
            const { x, y, width: w, height: h } = node;
            const r = 10; // radius
            // Define path for rounded rectangle
            ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath();

            const gradientEnabled = node.bgGradientEnabled === undefined ? NODE_DEFAULT_GRADIENT_ENABLED : node.bgGradientEnabled;
            if (gradientEnabled) {
                const color1 = node.bgColor1 || NODE_DEFAULT_GRADIENT_COLOR1;
                const color2 = node.bgColor2 || NODE_DEFAULT_GRADIENT_COLOR2;
                const direction = node.gradientDirection || NODE_DEFAULT_GRADIENT_DIRECTION;
                let x0, y0, x1, y1;
                if (direction === 'horizontal') { x0 = node.x; y0 = node.y + node.height / 2; x1 = node.x + node.width; y1 = node.y + node.height / 2; }
                else if (direction === 'diagonal1') { x0 = node.x; y0 = node.y; x1 = node.x + node.width; y1 = node.y + node.height; }
                else if (direction === 'diagonal2') { x0 = node.x + node.width; y0 = node.y; x1 = node.x; y1 = node.y + node.height; }
                else { x0 = node.x + node.width / 2; y0 = node.y; x1 = node.x + node.width / 2; y1 = node.y + node.height; } // Default vertical
                const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
                gradient.addColorStop(0, color1);
                gradient.addColorStop(1, color2);
                ctx.fillStyle = gradient;
                ctx.fill();
            } else {
                ctx.fill(); // Uses node.color (or default) set before calling this function
                if (node.nodeBgImageObj) { // Draw image on top of solid color if gradient is not enabled
                    drawNodeBackgroundPattern(ctx, node, node.nodeBgImageObj);
                }
            }
            ctx.stroke(); // Always stroke border
        };
        const drawEllipseNode = (ctx, node) => {
            const { x, y, width: w, height: h } = node;
            const cx = x + w / 2; const cy = y + h / 2; const rx = w / 2; const ry = h / 2;
            if (rx <= 0 || ry <= 0) return;
            ctx.beginPath(); ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);

            const gradientEnabled = node.bgGradientEnabled === undefined ? NODE_DEFAULT_GRADIENT_ENABLED : node.bgGradientEnabled;
            if (gradientEnabled) {
                const color1 = node.bgColor1 || NODE_DEFAULT_GRADIENT_COLOR1;
                const color2 = node.bgColor2 || NODE_DEFAULT_GRADIENT_COLOR2;
                const direction = node.gradientDirection || NODE_DEFAULT_GRADIENT_DIRECTION;
                let x0, y0, x1, y1;
                if (direction === 'horizontal') { x0 = node.x; y0 = cy; x1 = node.x + w; y1 = cy; }
                else if (direction === 'diagonal1') { x0 = node.x; y0 = node.y; x1 = node.x + w; y1 = node.y + h; }
                else if (direction === 'diagonal2') { x0 = node.x + w; y0 = node.y; x1 = node.x; y1 = node.y + h; }
                else { x0 = cx; y0 = node.y; x1 = cx; y1 = node.y + h; } // Default vertical
                const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
                gradient.addColorStop(0, color1);
                gradient.addColorStop(1, color2);
                ctx.fillStyle = gradient;
                ctx.fill();
            } else {
                ctx.fill();
                if (node.nodeBgImageObj) { drawNodeBackgroundPattern(ctx, node, node.nodeBgImageObj); }
            }
            ctx.stroke();
        };
        const drawDiamondNode = (ctx, node) => {
            const { x, y, width: w, height: h } = node;
            const p1x = x + w / 2, p1y = y; const p2x = x + w, p2y = y + h / 2; const p3x = x + w / 2, p3y = y + h; const p4x = x, p4y = y + h / 2;
            ctx.beginPath(); ctx.moveTo(p1x, p1y); ctx.lineTo(p2x, p2y); ctx.lineTo(p3x, p3y); ctx.lineTo(p4x, p4y); ctx.closePath();

            const gradientEnabled = node.bgGradientEnabled === undefined ? NODE_DEFAULT_GRADIENT_ENABLED : node.bgGradientEnabled;
            if (gradientEnabled) {
                const color1 = node.bgColor1 || NODE_DEFAULT_GRADIENT_COLOR1;
                const color2 = node.bgColor2 || NODE_DEFAULT_GRADIENT_COLOR2;
                const direction = node.gradientDirection || NODE_DEFAULT_GRADIENT_DIRECTION;
                let x0, y0, x1, y1;
                // For diamond, gradient coordinates might need to span the bounding box for simplicity
                if (direction === 'horizontal') { x0 = node.x; y0 = node.y + node.height / 2; x1 = node.x + node.width; y1 = node.y + node.height / 2;}
                else if (direction === 'diagonal1') { x0 = node.x; y0 = node.y; x1 = node.x + node.width; y1 = node.y + node.height; }
                else if (direction === 'diagonal2') { x0 = node.x + node.width; y0 = node.y; x1 = node.x; y1 = node.y + node.height; }
                else { x0 = node.x + node.width / 2; y0 = node.y; x1 = node.x + node.width / 2; y1 = node.y + node.height; } // Default vertical
                const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
                gradient.addColorStop(0, color1);
                gradient.addColorStop(1, color2);
                ctx.fillStyle = gradient;
                ctx.fill();
            } else {
                ctx.fill();
                if (node.nodeBgImageObj) { drawNodeBackgroundPattern(ctx, node, node.nodeBgImageObj); }
            }
            ctx.stroke();
        };
        const drawTriangleNode = (ctx, node) => {
            const { x, y, width: w, height: h } = node;
            const p1x = x + w / 2, p1y = y; const p2x = x + w, p2y = y + h; const p3x = x, p3y = y + h;
            ctx.beginPath(); ctx.moveTo(p1x, p1y); ctx.lineTo(p2x, p2y); ctx.lineTo(p3x, p3y); ctx.closePath();

            const gradientEnabled = node.bgGradientEnabled === undefined ? NODE_DEFAULT_GRADIENT_ENABLED : node.bgGradientEnabled;
            if (gradientEnabled) {
                const color1 = node.bgColor1 || NODE_DEFAULT_GRADIENT_COLOR1;
                const color2 = node.bgColor2 || NODE_DEFAULT_GRADIENT_COLOR2;
                const direction = node.gradientDirection || NODE_DEFAULT_GRADIENT_DIRECTION;
                let x0, y0, x1, y1;
                if (direction === 'horizontal') { x0 = node.x; y0 = node.y + node.height / 2; x1 = node.x + node.width; y1 = node.y + node.height / 2;}
                else if (direction === 'diagonal1') { x0 = node.x; y0 = node.y; x1 = node.x + node.width; y1 = node.y + node.height; }
                else if (direction === 'diagonal2') { x0 = node.x + node.width; y0 = node.y; x1 = node.x; y1 = node.y + node.height; }
                else { x0 = node.x + node.width / 2; y0 = node.y; x1 = node.x + node.width / 2; y1 = node.y + node.height; } // Default vertical
                const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
                gradient.addColorStop(0, color1);
                gradient.addColorStop(1, color2);
                ctx.fillStyle = gradient;
                ctx.fill();
            } else {
                ctx.fill();
                if (node.nodeBgImageObj) { drawNodeBackgroundPattern(ctx, node, node.nodeBgImageObj); }
            }
            ctx.stroke();
        };

        const drawNodeImageIndicator = (ctx, node, currentScale) => { const r = IMAGE_INDICATOR_SIZE / 2; const x = node.x + node.width - r; const y = node.y + r; ctx.save(); ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fillStyle = IMAGE_INDICATOR_COLOR; ctx.fill(); ctx.strokeStyle = 'white'; ctx.lineWidth = 1 / currentScale; ctx.stroke(); ctx.restore(); };
        const drawConnectionEndpointCircle = (ctx, x, y, currentScale) => { ctx.save(); ctx.beginPath(); ctx.arc(x, y, CONNECTION_END_HOVER_RADIUS / currentScale, 0, Math.PI * 2); ctx.fillStyle = 'rgba(59, 130, 246, 0.5)'; ctx.fill(); ctx.restore(); };

        const ModalComponent = {
            props: { isOpen: Boolean, title: String, widthClass: { type: String, default: 'max-w-sm' } },
            emits: ['close'],
            template: `
                <div v-if="isOpen" class="fixed inset-0 modal-backdrop flex items-center justify-center z-50 p-4" @click="$emit('close')">
                    <div class="modal-content bg-slate-800 p-5 sm:p-6 rounded-lg shadow-xl w-full" :class="widthClass" @click.stop>
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-semibold text-white">{{ title }}</h3>
                            <button @click="$emit('close')" class="text-gray-500 hover:text-gray-300 transition-colors">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <slot></slot>
                    </div>
                </div>`
        };

        const app = Vue.createApp({
            components: { 'modal': ModalComponent },
            data() {
                return {
                    nodes: [], selectedNodeId: null, offsetX: 0, offsetY: 0, scale: 1,
                    isTextEditModalOpen: false, 
                    nodeToEditTextId: null, 
                    nodeTextInput: '',
                    isImagePreviewModalOpen: false, 
                    previewImageUrl: '',
                    isDeleteConfirmModalOpen: false, 
                    nodeToDeleteId: null,
                    isErrorModalOpen: false, 
                    errorModalTitle: 'Erreur', 
                    errorModalMessage: '', 
                    errorModalType: 'error', // 'error', 'success', 'info'
                    isAboutModalOpen: false,
                    isSidebarOpen: false, // For sidebar visibility
                    isHyperlinkModalOpen: false, 
                    hyperlinkInput: '', 
                    nodeToEditHyperlinkId: null,
                    contextMenu: { visible: false, x: 0, y: 0, nodeId: null, rawX: 0, rawY: 0 },
                    fileMenu: { visible: false, top: '0px', left: '0px' },
                    draggedNodeId: null, isDragging: false, isPanning: false, panStart: { x: 0, y: 0 }, dragStart: { x: 0, y: 0 },
                    isLinking: false, // For context menu "Connect to another..."
                    linkStartNodeId: null, // For context menu "Connect to another..."
                    isDraggingLink: false, // For Alt+Drag to create/link node
                    linkDragStartNodeId: null, // For Alt+Drag
                    linkDragEndPos: null, // For Alt+Drag
                    potentialLinkTargetId: null, // For Alt+Drag, highlights node under cursor
                    potentialDropTargetId: null, // For node drag reparenting, highlights node under cursor
                    hoveredNodeId: null, isAnimating: false, lastMousePos: { clientX: 0, clientY: 0 }, hoveredConnectionId: null, draggingConnectionEnd: null, potentialEndPoint: null,
                    canvasBgColor: DEFAULT_CANVAS_BG_COLOR,
                    history: [], currentHistoryIndex: -1,
                    availableIcons: AVAILABLE_ICONS, availableBorderStyles: AVAILABLE_BORDER_STYLES,
                    NODE_DEFAULT_FONT_SIZE, NODE_DEFAULT_FONT_FAMILY, AVAILABLE_FONT_FAMILIES, NODE_DEFAULT_PADDING,
                    NODE_DEFAULT_SHADOW_ENABLED, NODE_DEFAULT_SHADOW_COLOR, NODE_DEFAULT_SHADOW_BLUR, NODE_DEFAULT_SHADOW_OFFSET_X, NODE_DEFAULT_SHADOW_OFFSET_Y,
                    NODE_DEFAULT_GRADIENT_ENABLED, NODE_DEFAULT_GRADIENT_COLOR1, NODE_DEFAULT_GRADIENT_COLOR2, NODE_DEFAULT_GRADIENT_DIRECTION, AVAILABLE_GRADIENT_DIRECTIONS, // Gradient properties
                    CONNECTION_POINTS: CONNECTION_POINTS, CONNECTION_TYPES: CONNECTION_TYPES, NODE_SHAPES: NODE_SHAPES,
                    previewConnectionSide: null,
                    autosaveIntervalId: null,
                }
            },
            computed: {
                dynamicStyles() { return getDynamicDrawingStyles(); },
                selectedNode() { return this.findNodeById(this.selectedNodeId); },
                errorModalTypeClass() { if (this.errorModalType === 'success') return 'text-green-400'; if (this.errorModalType === 'info') return 'text-blue-400'; return 'text-red-400'; },
                contextSubmenuOpenLeft() { if (this.$refs.contextMenuElement) { const menuWidth = this.$refs.contextMenuElement.offsetWidth || 200; const submenuWidthEstimate = 180; return this.contextMenu.x + menuWidth + submenuWidthEstimate > window.innerWidth; } return false; },
                isMobileView() {
                    return window.innerWidth < 640; // Tailwind 'sm' breakpoint
                },
                fileMenuSubmenuOpenLeft() {
                    if (this.$refs.fileMenuElement) {
                        const menuRect = this.$refs.fileMenuElement.getBoundingClientRect();
                        const submenuWidthEstimate = 200;
                        return menuRect.left + menuRect.width + submenuWidthEstimate > window.innerWidth;
                    }
                    return false;
                },
                canUndo() { return this.currentHistoryIndex > 0; },
                canRedo() { return this.currentHistoryIndex < this.history.length - 1; },
                hasRootNode() { return this.nodes.some(n => n.parentId === null || n.parentId === undefined); },
            },
            watch: {
                canvasBgColor(newValue, oldValue) {
                    if(newValue !== oldValue) {
                        this.recordHistory("Change Canvas Bg");
                        this.redrawCanvas();
                    }
                },
                nodes: { handler() { this.redrawCanvas(); }, deep: true },
                offsetX() { this.redrawCanvas(); }, offsetY() { this.redrawCanvas(); }, scale() { this.redrawCanvas(); },
                selectedNodeId() { this.redrawCanvas(); },
                potentialDropTargetId() { this.redrawCanvas(); }, potentialLinkTargetId() { this.redrawCanvas(); }, // Covers both node-drag and alt-drag linking highlights
                hoveredNodeId() { this.redrawCanvas(); }, hoveredConnectionId() { this.redrawCanvas(); },
                draggingConnectionEnd() { this.redrawCanvas(); },
                isDraggingLink() { this.redrawCanvas(); },
                isLinking() { this.redrawCanvas(); },
                previewConnectionSide() { this.redrawCanvas(); }
            },
            async mounted() {
                this.resizeCanvas();
                window.addEventListener('resize', this.resizeCanvas);
                let didLoad = await this.loadMapFromLocalStorage();

                if (!didLoad && !this.hasRootNode) {
                    this.$nextTick(() => {
                         this.addInitialNode();
                    });
                } else if (this.nodes.length > 0 && this.history.length === 0) {
                     this.recordHistory("Load Initial Map");
                } else if (this.history.length > 0 && this.currentHistoryIndex === -1 && this.nodes.length > 0){
                     this.currentHistoryIndex = this.history.length - 1;
                }

                document.addEventListener('click', this.handleGlobalClick);
                document.addEventListener('keydown', this.handleGlobalKeyDown);

                const canvas = this.$refs.mindMapCanvas;
                canvas.addEventListener('touchstart', this.handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', this.handleTouchMove, { passive: false });
                canvas.addEventListener('touchend', this.handleTouchEnd);
                canvas.addEventListener('touchcancel', this.handleTouchCancel);

                this.autosaveIntervalId = setInterval(() => {
                    this.saveMapToLocalStorage(true);
                }, AUTOSAVE_INTERVAL);

                this.$nextTick(() => {
                    this.isTextEditModalOpen = false;
                    this.isHyperlinkModalOpen = false;
                    this.isImagePreviewModalOpen = false;
                    this.isDeleteConfirmModalOpen = false;
                    this.isAboutModalOpen = false;
                    this.isErrorModalOpen = false;
                    this.isSidebarOpen = false; // Ensure sidebar is closed on init
                    this.contextMenu.visible = false;
                    this.fileMenu.visible = false;
                });
            },
            beforeUnmount() {
                window.removeEventListener('resize', this.handleResizeForSidebar);
                document.removeEventListener('click', this.handleGlobalClick);
                document.removeEventListener('keydown', this.handleGlobalKeyDown);

                const canvas = this.$refs.mindMapCanvas;
                if (canvas) {
                    canvas.removeEventListener('touchstart', this.handleTouchStart);
                    canvas.removeEventListener('touchmove', this.handleTouchMove);
                    canvas.removeEventListener('touchend', this.handleTouchEnd);
                    canvas.removeEventListener('touchcancel', this.handleTouchCancel);
                }

                if (this.autosaveIntervalId) {
                    clearInterval(this.autosaveIntervalId);
                }
            },
            methods: {
                // Touch event processing
                getTouchPos(e, touchIndex = 0, canvasEl = this.$refs.mindMapCanvas) {
                    if (!canvasEl || !e.touches || e.touches.length <= touchIndex) return { x: 0, y: 0, clientX: 0, clientY: 0, identifier: -1 };
                    const touch = e.touches[touchIndex];
                    const rect = canvasEl.getBoundingClientRect();
                    const mx = touch.clientX - rect.left;
                    const my = touch.clientY - rect.top;
                    return {
                        x: (mx - this.offsetX) / this.scale,
                        y: (my - this.offsetY) / this.scale,
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        identifier: touch.identifier
                    };
                },
                handleTouchStart(e) {
                    e.preventDefault();
                    this.hideContextMenu(); // Hide any visible context menu
                    if(this.fileMenu.visible) this.fileMenu.visible = false;

                    // Update active touches
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        this.activeTouchIds.add(e.changedTouches[i].identifier);
                    }

                    if (this.activeTouchIds.size === 1) { // Use activeTouchIds.size for current number of fingers on screen
                        const touch = e.touches[0]; // The first touch in the current list
                        this.lastTouchPos = { clientX: touch.clientX, clientY: touch.clientY, identifier: touch.identifier };
                        const pos = this.getTouchPos({touches: [touch]}); // Pass a consistent structure to getTouchPos

                        // Long press for context menu
                        this.longPressStartPos = { x: touch.clientX, y: touch.clientY, worldX: pos.x, worldY: pos.y };
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = setTimeout(() => {
                            if (this.activeTouchIds.size === 1 && this.activeTouchIds.has(this.lastTouchPos.identifier) ) {
                                let currentTouchForLongPress = null;
                                // e.touches might be stale if called from timeout, ideally use stored initial touch data if movement check passed
                                // However, for simplicity, we check current screen position of the tracked finger if it still exists
                                 const liveTouches = this.$refs.mindMapCanvas.getRootNode().ownerDocument.defaultView.event?.touches || e.touches; // Attempt to get live touches
                                for(let i=0; i < liveTouches.length; i++){
                                    if(liveTouches[i].identifier === this.lastTouchPos.identifier){
                                        currentTouchForLongPress = liveTouches[i];
                                        break;
                                    }
                                }

                                if (currentTouchForLongPress) {
                                     const dx = currentTouchForLongPress.clientX - this.longPressStartPos.x;
                                     const dy = currentTouchForLongPress.clientY - this.longPressStartPos.y;
                                     if (Math.sqrt(dx * dx + dy * dy) < 10) {
                                        const nodeForContextMenu = this.getNodeAtPos(this.longPressStartPos.worldX, this.longPressStartPos.worldY);
                                        this.contextMenu = {
                                            visible: true,
                                            x: this.longPressStartPos.x,
                                            y: this.longPressStartPos.y,
                                            nodeId: nodeForContextMenu ? nodeForContextMenu.id : null,
                                            rawX: this.longPressStartPos.worldX,
                                            rawY: this.longPressStartPos.worldY
                                        };
                                        this.$nextTick(() => { this.adjustContextMenuPosition(); });
                                     }
                                } else if (Math.sqrt(Math.pow(this.lastTouchPos.clientX - this.longPressStartPos.x, 2) + Math.pow(this.lastTouchPos.clientY - this.longPressStartPos.y, 2)) < 10 && !this.isDragging && !this.isPanning) {
                                    // Fallback if live touch not found but original touch didn't move much and no other interaction started
                                     const nodeForContextMenu = this.getNodeAtPos(this.longPressStartPos.worldX, this.longPressStartPos.worldY);
                                     this.contextMenu = { visible: true, x: this.longPressStartPos.x, y: this.longPressStartPos.y, nodeId: nodeForContextMenu ? nodeForContextMenu.id : null, rawX: this.longPressStartPos.worldX, rawY: this.longPressStartPos.worldY };
                                     this.$nextTick(() => { this.adjustContextMenuPosition(); });
                                }
                            }
                            this.longPressTimer = null;
                        }, 700);


                        const clickedNode = this.getNodeAtPos(pos.x, pos.y);
                        if (clickedNode) {
                            this.isDragging = true;
                            this.draggedNodeId = clickedNode.id;
                            if (this.selectedNodeId !== clickedNode.id) {
                                this.selectedNodeId = clickedNode.id;
                            }
                            this.dragStart = { ...pos };

                            const draggedNode = this.findNodeById(this.draggedNodeId);
                            if (draggedNode) {
                                if (draggedNode.parentId !== null && draggedNode.entryPoint === null) {
                                    const parentOfDragged = this.findNodeById(draggedNode.parentId);
                                    if (parentOfDragged) { const dp = this.calculateDefaultConnectionPoints(parentOfDragged, draggedNode); draggedNode._frozenEntryPoint = dp.entryPoint; }
                                }
                                this.nodes.forEach(node => {
                                    if (node.parentId === draggedNode.id && node.entryPoint === null) { const dp = this.calculateDefaultConnectionPoints(draggedNode, node); node._frozenEntryPoint = dp.entryPoint; }
                                });
                                if (draggedNode.parentId !== null) {
                                    const parentNode = this.findNodeById(draggedNode.parentId);
                                    if (parentNode) { if (draggedNode.parentExitPoint === null) { const dp = this.calculateDefaultConnectionPoints(parentNode, draggedNode); draggedNode._frozenParentExitPointOnParent = dp.parentExitPoint; } }
                                }
                            }
                        } else {
                            this.isPanning = true;
                            this.panStart = { x: touch.clientX - this.offsetX, y: touch.clientY - this.offsetY };
                            if (this.selectedNodeId !== null) this.selectedNodeId = null;
                        }
                    } else if (this.activeTouchIds.size === 2) {
                        clearTimeout(this.longPressTimer); this.longPressTimer = null;
                        this.isPanning = false; this.isDragging = false;
                        if (e.touches.length >= 2) {
                            const t1 = e.touches[0];
                            const t2 = e.touches[1];
                            this.initialPinchDistance = Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2));
                        } else {
                             this.initialPinchDistance = null;
                        }
                    }
                },
                handleTouchMove(e) {
                    e.preventDefault();

                    const currentTrackedTouch = Array.from(e.touches).find(t => this.lastTouchPos && t.identifier === this.lastTouchPos.identifier);

                    if (this.longPressTimer && currentTrackedTouch && this.longPressStartPos) {
                        const dx = currentTrackedTouch.clientX - this.longPressStartPos.x;
                        const dy = currentTrackedTouch.clientY - this.longPressStartPos.y;
                        if (Math.sqrt(dx * dx + dy * dy) >= 10) {
                            clearTimeout(this.longPressTimer);
                            this.longPressTimer = null;
                        }
                    }

                    if (this.activeTouchIds.size === 1 && currentTrackedTouch) {
                        const pos = this.getTouchPos({touches: [currentTrackedTouch]});

                        if (this.isDragging && this.draggedNodeId) {
                            const draggedNode = this.findNodeById(this.draggedNodeId);
                            if (draggedNode) {
                                const dx = pos.x - this.dragStart.x;
                                const dy = pos.y - this.dragStart.y;

                                this.prepareLinkAnimation(draggedNode);
                                this.nodes.forEach(n => { if (n.parentId === draggedNode.id) this.prepareLinkAnimation(n); });

                                draggedNode.x += dx;
                                draggedNode.y += dy;
                                this.dragStart = { ...pos };

                                let currentPotentialTarget = null; let minDistanceSq = Infinity; const thresholdSq = (REPARENT_PROXIMITY_THRESHOLD / this.scale) ** 2;
                                this.nodes.forEach(targetNode => {
                                    if (targetNode.id === this.draggedNodeId) return;
                                    const targetCenterX = targetNode.x + targetNode.width / 2;
                                    const targetCenterY = targetNode.y + targetNode.height / 2;
                                    const distSq = (pos.x - targetCenterX) ** 2 + (pos.y - targetCenterY) ** 2;
                                    if (distSq < minDistanceSq && distSq <= thresholdSq) {
                                        const dgd = this.findNodeById(this.draggedNodeId);
                                        if (dgd && targetNode.id !== dgd.parentId && !this.isAncestor(this.draggedNodeId, targetNode.id)) {
                                            minDistanceSq = distSq; currentPotentialTarget = targetNode.id;
                                        }
                                    }
                                });
                                if (this.potentialDropTargetId !== currentPotentialTarget) this.potentialDropTargetId = currentPotentialTarget;
                            }
                        } else if (this.isPanning) {
                            this.offsetX = currentTrackedTouch.clientX - this.panStart.x;
                            this.offsetY = currentTrackedTouch.clientY - this.panStart.y;
                        }
                        this.lastTouchPos.clientX = currentTrackedTouch.clientX;
                        this.lastTouchPos.clientY = currentTrackedTouch.clientY;

                    } else if (this.activeTouchIds.size === 2 && this.initialPinchDistance != null && e.touches.length >=2) {
                        const t1 = e.touches[0];
                        const t2 = e.touches[1];
                        const currentPinchDistance = Math.sqrt(Math.pow(t1.clientX - t2.clientX, 2) + Math.pow(t1.clientY - t2.clientY, 2));

                        if (this.initialPinchDistance === 0) {
                            this.initialPinchDistance = currentPinchDistance > 0 ? currentPinchDistance : 1;
                        }
                        if (this.initialPinchDistance > 0) { // Ensure initialPinchDistance is not zero
                            const scaleFactor = currentPinchDistance / this.initialPinchDistance;
                            const midX = (t1.clientX + t2.clientX) / 2;
                            const midY = (t1.clientY + t2.clientY) / 2;
                            this.zoom(scaleFactor, midX, midY);
                        }
                        this.initialPinchDistance = currentPinchDistance;
                    }
                },
                handleTouchEnd(e) {
                    clearTimeout(this.longPressTimer);
                    this.longPressTimer = null;

                    const wasDragging = this.isDragging;
                    const wasPanning = this.isPanning;
                    let stateChangedByInteraction = false;
                    let zoomChangedInThisGesture = this.initialPinchDistance !== null && this.activeTouchIds.size <= e.changedTouches.length;


                    for (let i = 0; i < e.changedTouches.length; i++) {
                        const touchId = e.changedTouches[i].identifier;
                        this.activeTouchIds.delete(touchId);
                        if(this.lastTouchPos && touchId === this.lastTouchPos.identifier) {
                            this.lastTouchPos.identifier = -1;
                        }
                    }

                    if (wasDragging && this.draggedNodeId) {
                        if (this.potentialDropTargetId) {
                            const draggedNode = this.findNodeById(this.draggedNodeId);
                            const targetNode = this.findNodeById(this.potentialDropTargetId);
                            if (draggedNode && targetNode && draggedNode.id !== targetNode.id && draggedNode.parentId !== targetNode.id && !this.isAncestor(draggedNode.id, targetNode.id)) {
                                this.prepareLinkAnimation(draggedNode);
                                const cpts = this.calculateDefaultConnectionPoints(targetNode, draggedNode);
                                draggedNode.parentId = targetNode.id;
                                draggedNode.parentExitPoint = cpts.parentExitPoint;
                                if (!draggedNode.entryPoint || draggedNode.entryPoint === 'auto') draggedNode.entryPoint = cpts.entryPoint;
                                stateChangedByInteraction = true;
                            }
                        } else { stateChangedByInteraction = true; }
                        this.nodes.forEach(node => { delete node._frozenEntryPoint; delete node._frozenParentExitPointOnParent; });
                    }


                    if (e.changedTouches.length === 1 && this.activeTouchIds.size === 0 && !wasDragging && !wasPanning && !zoomChangedInThisGesture && !stateChangedByInteraction) {
                        const touch = e.changedTouches[0];
                        const rect = this.$refs.mindMapCanvas.getBoundingClientRect();
                        const mx = touch.clientX - rect.left;
                        const my = touch.clientY - rect.top;
                        const worldX = (mx - this.offsetX) / this.scale;
                        const worldY = (my - this.offsetY) / this.scale;

                        const tappedNode = this.getNodeAtPos(worldX, worldY);
                        const currentTime = Date.now();

                        if (tappedNode) {
                            if (currentTime - this.lastTapTimestamp < 300 && this.lastTapNodeId === tappedNode.id) {
                                this.handleDoubleClick({ clientX: touch.clientX, clientY: touch.clientY, preventDefault: () => {} }); // Pass clientX/Y for consistency if dblclick handlers use it
                                this.lastTapTimestamp = 0; this.lastTapNodeId = null;
                            } else {
                                if(this.selectedNodeId !== tappedNode.id) this.selectedNodeId = tappedNode.id;
                                else this.selectedNodeId = null; // Allow deselect by tapping selected node again

                                this.lastTapTimestamp = currentTime; this.lastTapNodeId = tappedNode.id;
                            }
                        } else {
                            this.selectedNodeId = null; // Tap on empty space deselects
                            this.lastTapTimestamp = 0; // Reset for next tap sequence
                            this.lastTapNodeId = null;
                        }
                    }

                    if (stateChangedByInteraction) this.recordHistory("Node Interaction (Touch)");
                    if (zoomChangedInThisGesture) this.recordHistory("Zoom View (Touch)");

                    if (this.activeTouchIds.size === 0) {
                        this.resetTouchStates();
                    } else if (this.activeTouchIds.size === 1) {
                        this.initialPinchDistance = null;
                        this.isDragging = false; this.isPanning = false;

                        const remainingTouchIdentifier = this.activeTouchIds.values().next().value;
                        let remainingTouch = null;
                        for(let i=0; i < e.touches.length; i++){
                            if(e.touches[i].identifier === remainingTouchIdentifier){
                                remainingTouch = e.touches[i];
                                break;
                            }
                        }

                        if(remainingTouch){
                            this.lastTouchPos = { clientX: remainingTouch.clientX, clientY: remainingTouch.clientY, identifier: remainingTouch.identifier };
                            const pos = this.getTouchPos({touches: [remainingTouch]});
                            const clickedNode = this.getNodeAtPos(pos.x, pos.y);
                            if (clickedNode) {
                                this.isDragging = true; this.draggedNodeId = clickedNode.id; this.selectedNodeId = clickedNode.id; this.dragStart = { ...pos };
                            } else {
                                this.isPanning = true; this.panStart = { x: remainingTouch.clientX - this.offsetX, y: remainingTouch.clientY - this.offsetY };
                            }
                        } else {
                            this.resetTouchStates();
                        }
                    }
                },
                handleTouchCancel(e) {
                    clearTimeout(this.longPressTimer);
                    this.longPressTimer = null;
                    this.nodes.forEach(node => { delete node._frozenEntryPoint; delete node._frozenParentExitPointOnParent; });
                    this.resetTouchStates();
                },
                resetTouchStates() {
                    this.isDragging = false;
                    this.isPanning = false;
                    this.draggedNodeId = null;
                    this.potentialDropTargetId = null;
                    this.cancelDragLinking();
                    this.potentialLinkTargetId = null;

                    this.activeTouchIds.clear();
                    this.longPressStartPos = null;
                    clearTimeout(this.longPressTimer);
                    this.longPressTimer = null;
                    this.initialPinchDistance = null;
                    if (this.lastTouchPos) this.lastTouchPos.identifier = -1;
                    // lastTapTimestamp and lastTapNodeId are intentionally not reset here
                    // as they are part of the double-tap detection logic across separate touch end events.
                    // They are reset when a double tap successfully occurs or when a tap on empty space occurs.
                },

                toggleFileMenu(event) {
                    if (this.fileMenu.visible) {
                        this.fileMenu.visible = false;
                    } else {
                        // Close other UI elements before opening file menu
                        this.hideContextMenu(); // Also clears previewConnectionSide
                        if (this.isMobileView && this.isSidebarOpen) {
                            this.isSidebarOpen = false;
                            // If sidebar closing affects layout, might need $nextTick before calc, but usually not for overlay
                        }

                        const buttonRect = event.currentTarget.getBoundingClientRect();
                        this.fileMenu.top = `${buttonRect.bottom + window.scrollY}px`;
                        this.fileMenu.left = `${buttonRect.left + window.scrollX}px`;
                        this.fileMenu.visible = true;
                    }
                },
                setPreviewConnectionSide(nodeId, property, value) {
                    this.previewConnectionSide = { nodeId, property, value };
                },
                clearPreviewConnectionSide() {
                    this.previewConnectionSide = null;
                },
                recordHistory(actionName = "Unknown Action") {
                    const serializedNodes = JSON.parse(JSON.stringify(this.nodes.map(n => { const { imageObj, ...rest } = n; return rest; })));
                    const state = {
                        nodes: serializedNodes,
                        viewState: { offsetX: this.offsetX, offsetY: this.offsetY, scale: this.scale },
                        selectedNodeId: this.selectedNodeId,
                        canvasBgColor: this.canvasBgColor,
                    };
                    if (this.currentHistoryIndex < this.history.length - 1) {
                        this.history = this.history.slice(0, this.currentHistoryIndex + 1);
                    }
                    this.history.push(state);
                    if (this.history.length > MAX_HISTORY_STATES) { this.history.shift(); }
                    this.currentHistoryIndex = this.history.length - 1;
                },
                loadStateFromHistory(state) {
                    this.nodes = JSON.parse(JSON.stringify(state.nodes)).map(nodeData => {
                        const node = { ...nodeData, imageObj: null };
                        if (node.imageUrl) {
                            const img = new Image();
                            img.onload = () => { node.imageObj = img; this.redrawCanvas(); };
                            img.onerror = () => { node.imageUrl = null; };
                            img.src = node.imageUrl;
                        }
                        return node;
                    });
                    this.offsetX = state.viewState.offsetX; this.offsetY = state.viewState.offsetY;
                    this.scale = state.viewState.scale; this.selectedNodeId = state.selectedNodeId;
                    this.canvasBgColor = state.canvasBgColor;
                    this.redrawCanvas();
                },
                undo() { if (this.canUndo) { this.currentHistoryIndex--; this.loadStateFromHistory(this.history[this.currentHistoryIndex]); } },
                redo() { if (this.canRedo) { this.currentHistoryIndex++; this.loadStateFromHistory(this.history[this.currentHistoryIndex]); } },

                redrawCanvas() {
                    const canvas = this.$refs.mindMapCanvas;
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    if (!ctx || canvas.width <= 0 || canvas.height <= 0) return;

                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.save();
                    ctx.translate(this.offsetX, this.offsetY);
                    ctx.scale(this.scale, this.scale);

                    const ds = getDynamicDrawingStyles();
                    ctx.lineWidth = 2;

                    this.nodes.forEach(child => {
                        if (!child || child.parentId === null || child.parentId === undefined) return;
                        const parent = this.findNodeById(child.parentId);
                        if (parent) {
                            let resolvedParentExitPoint = child.parentExitPoint;
                            let resolvedChildEntryPoint = child.entryPoint;
                            let resolvedConnectionType = child.connectionType || 'solid';

                            // Apply frozen points if dragging relevant nodes
                            if (this.isDragging) {
                                if (child.id === this.draggedNodeId && child._frozenEntryPoint) {
                                    resolvedChildEntryPoint = child._frozenEntryPoint;
                                }
                                // If the parent is being dragged and this child's connection to it had an auto exit point (on the parent)
                                if (parent.id === this.draggedNodeId && child._frozenParentExitPointOnParent) {
                                     resolvedParentExitPoint = child._frozenParentExitPointOnParent;
                                }
                                // If this child's parent is the dragged node, and this child's entry point was auto
                                if (child.parentId === this.draggedNodeId && child._frozenEntryPoint) {
                                    resolvedChildEntryPoint = child._frozenEntryPoint;
                                }
                            }

                            if (resolvedParentExitPoint === null && resolvedChildEntryPoint === null) {
                                const dp = this.calculateDefaultConnectionPoints(parent, child);
                                resolvedParentExitPoint = dp.parentExitPoint;
                                resolvedChildEntryPoint = dp.entryPoint;
                            } else if (resolvedParentExitPoint === null) {
                                const dp = this.calculateDefaultConnectionPoints(parent, child);
                                resolvedParentExitPoint = dp.parentExitPoint;
                            } else if (resolvedChildEntryPoint === null) {
                                const dp = this.calculateDefaultConnectionPoints(parent, child);
                                resolvedChildEntryPoint = dp.entryPoint;
                            }

                            let finalDrawParentExit = resolvedParentExitPoint;
                            let finalDrawChildEntry = resolvedChildEntryPoint;
                            let isStylingPreview = false; // True if any visual aspect (points or type) is being previewed for this child.

                            let isBeingDraggedEndpoint = this.draggingConnectionEnd && this.draggingConnectionEnd.childId === child.id;

                            if (this.previewConnectionSide && this.previewConnectionSide.nodeId === child.id) {
                                isStylingPreview = true; // A preview is active for this child's connection
                                if (this.previewConnectionSide.property === 'parentExitPoint') {
                                    finalDrawParentExit = (this.previewConnectionSide.value === 'auto') ? null : this.previewConnectionSide.value;
                                } else if (this.previewConnectionSide.property === 'entryPoint') {
                                    finalDrawChildEntry = (this.previewConnectionSide.value === 'auto') ? null : this.previewConnectionSide.value;
                                } else if (this.previewConnectionSide.property === 'connectionType') {
                                    resolvedConnectionType = this.previewConnectionSide.value;
                                }
                            }

                            // Re-resolve if preview set a point to 'auto' (null)
                            if (finalDrawParentExit === null && finalDrawChildEntry === null) {
                                const dp = this.calculateDefaultConnectionPoints(parent, child);
                                finalDrawParentExit = dp.parentExitPoint;
                                finalDrawChildEntry = dp.entryPoint;
                            } else if (finalDrawParentExit === null) {
                                const dp = this.calculateDefaultConnectionPoints(parent, child);
                                finalDrawParentExit = dp.parentExitPoint;
                            } else if (finalDrawChildEntry === null) {
                                const dp = this.calculateDefaultConnectionPoints(parent, child);
                                finalDrawChildEntry = dp.entryPoint;
                            }

                            // Final fallback if still null (should ideally not happen if calculateDefaultConnectionPoints is robust)
                            finalDrawParentExit = finalDrawParentExit || 'bottom';
                            finalDrawChildEntry = finalDrawChildEntry || 'top';

                            let finalP0, finalP3;

                            if (isBeingDraggedEndpoint && this.potentialEndPoint) {
                                if (this.draggingConnectionEnd.endType === 'parentExit') {
                                    finalP0 = this.potentialEndPoint.coords;
                                    finalP3 = this.getConnectionPointCoords(child, finalDrawChildEntry);
                                } else { // 'childEntry'
                                    finalP0 = this.getConnectionPointCoords(parent, finalDrawParentExit);
                                    finalP3 = this.potentialEndPoint.coords;
                                }
                            } else {
                                finalP0 = this.getConnectionPointCoords(parent, finalDrawParentExit);
                                finalP3 = this.getConnectionPointCoords(child, finalDrawChildEntry);
                            }
                            
                            if (!finalP0 || !finalP3 || typeof finalP0.x !== 'number' || typeof finalP3.x !== 'number') return;

                            let P0 = { ...finalP0 };
                            let P3 = { ...finalP3 };

                            if (child.isLinkAnimating && child.linkPrevP0 && child.linkPrevP3) {
                                const elapsed = Date.now() - child.linkAnimationStartTime;
                                let progress = Math.min(1, elapsed / LINK_ANIMATION_DURATION);
                                progress = 1 - Math.pow(1 - progress, 3);
                                
                                P0.x = child.linkPrevP0.x + (finalP0.x - child.linkPrevP0.x) * progress;
                                P0.y = child.linkPrevP0.y + (finalP0.y - child.linkPrevP0.y) * progress;
                                P3.x = child.linkPrevP3.x + (finalP3.x - child.linkPrevP3.x) * progress;
                                P3.y = child.linkPrevP3.y + (finalP3.y - child.linkPrevP3.y) * progress;

                                if (progress >= 1) {
                                    child.isLinkAnimating = false;
                                    delete child.linkPrevP0;
                                    delete child.linkPrevP3;
                                    delete child.linkAnimationStartTime;
                                }
                            }

                            // Determine styling based on preview or actual state
                            if (isStylingPreview) { // isStylingPreview is true if any aspect (points or type) is being previewed
                                ctx.strokeStyle = CONNECTION_PREVIEW_COLOR;
                            } else if (child.id === this.hoveredConnectionId || isBeingDraggedEndpoint) {
                                ctx.strokeStyle = CONNECTION_HOVER_COLOR;
                            } else {
                                ctx.strokeStyle = ds.connectionColor;
                            }
                            ctx.fillStyle = ctx.strokeStyle; // For arrowhead

                            let P1 = { x: P0.x, y: P0.y }, P2 = { x: P3.x, y: P3.y };
                            const fixedOffset = 50;
                            
                            let effectiveParentExitSide = finalDrawParentExit;
                            let effectiveChildEntrySide = finalDrawChildEntry;

                            if (isBeingDraggedEndpoint && this.potentialEndPoint) {
                                if (this.draggingConnectionEnd.endType === 'parentExit') {
                                    effectiveParentExitSide = this.potentialEndPoint.side || finalDrawParentExit; // Fallback to finalDraw if side is undefined
                                } else { // 'childEntry'
                                    effectiveChildEntrySide = this.potentialEndPoint.side || finalDrawChildEntry; // Fallback to finalDraw if side is undefined
                                }
                            }
                            
                            switch (effectiveParentExitSide) { case 'top': P1.y -= fixedOffset; break; case 'bottom': P1.y += fixedOffset; break; case 'left': P1.x -= fixedOffset; break; case 'right': P1.x += fixedOffset; break; default: P1.y += fixedOffset; /* Default to bottom-like behavior */ break; }
                            switch (effectiveChildEntrySide) { case 'top': P2.y -= fixedOffset; break; case 'bottom': P2.y += fixedOffset; break; case 'left': P2.x -= fixedOffset; break; case 'right': P2.x += fixedOffset; break; default: P2.y -= fixedOffset; /* Default to top-like behavior */ break; }

                            // Use resolvedConnectionType which includes preview
                            if (resolvedConnectionType === 'dashed') ctx.setLineDash([7,4]);
                            else if (resolvedConnectionType === 'dotted') ctx.setLineDash([2,3]);
                            else ctx.setLineDash([]);

                            ctx.beginPath(); ctx.moveTo(P0.x, P0.y); ctx.bezierCurveTo(P1.x, P1.y, P2.x, P2.y, P3.x, P3.y); ctx.stroke();
                            if (resolvedConnectionType === 'arrow') drawArrowhead(ctx, P2.x, P2.y, P3.x, P3.y, 10);
                            ctx.setLineDash([]);

                            if (child.id === this.hoveredConnectionId || isBeingDraggedEndpoint) {
                                // Draw circles at the *actual* attachment points of the link being drawn
                                drawConnectionEndpointCircle(ctx, finalP0.x, finalP0.y, this.scale); 
                                drawConnectionEndpointCircle(ctx, finalP3.x, finalP3.y, this.scale); 
                            }
                        }
                    });

                    if (this.isDraggingLink && this.linkDragStartNodeId && this.linkDragEndPos) {
                        const startNode = this.findNodeById(this.linkDragStartNodeId);
                        if (startNode) {
                            const calculatedPoints = this.calculateDefaultConnectionPoints(startNode, {x: this.linkDragEndPos.x - NODE_DEFAULT_WIDTH/2, y: this.linkDragEndPos.y - NODE_DEFAULT_HEIGHT/2, width: NODE_DEFAULT_WIDTH, height: NODE_DEFAULT_HEIGHT});
                            const startCoords = this.getConnectionPointCoords(startNode, calculatedPoints.parentExitPoint);
                            ctx.save();
                            ctx.beginPath();
                            ctx.moveTo(startCoords.x, startCoords.y);
                            ctx.lineTo(this.linkDragEndPos.x, this.linkDragEndPos.y);
                            ctx.strokeStyle = TEMP_LINK_COLOR;
                            ctx.lineWidth = 2 / this.scale;
                            ctx.setLineDash([3,3]);
                            ctx.stroke();
                            ctx.restore();

                            if(this.potentialLinkTargetId){
                                 const targetNode = this.findNodeById(this.potentialLinkTargetId);
                                 if(targetNode){
                                    ctx.save();
                                    ctx.strokeStyle = NODE_LINK_TARGET_BORDER_COLOR;
                                    ctx.lineWidth = 3 / this.scale;
                                    const { x, y, width, height, shape } = targetNode;
                                    if (shape === 'ellipse') drawEllipseNode(ctx, targetNode);
                                    else if (shape === 'diamond') drawDiamondNode(ctx, targetNode);
                                    else if (shape === 'triangle') drawTriangleNode(ctx, targetNode);
                                    else strokeRoundRect(ctx, x, y, width, height, 10);
                                    ctx.restore();
                                 }
                            }
                        }
                    }
                    if (this.isLinking && this.linkStartNodeId && this.lastMousePos.clientX !== 0) {
                         const startNode = this.findNodeById(this.linkStartNodeId);
                         const mousePos = this.getMousePos(this.lastMousePos, canvas);
                         if (startNode) {
                            const tempTargetNode = { x: mousePos.x - NODE_DEFAULT_WIDTH/2, y: mousePos.y - NODE_DEFAULT_HEIGHT/2, width: NODE_DEFAULT_WIDTH, height: NODE_DEFAULT_HEIGHT};
                            const { parentExitPoint } = this.calculateDefaultConnectionPoints(startNode, tempTargetNode);
                            const startCoords = this.getConnectionPointCoords(startNode, parentExitPoint);
                            ctx.save();
                            ctx.beginPath();
                            ctx.moveTo(startCoords.x, startCoords.y);
                            ctx.lineTo(mousePos.x, mousePos.y);
                            ctx.strokeStyle = TEMP_LINK_COLOR;
                            ctx.lineWidth = 2 / this.scale;
                            ctx.setLineDash([5,5]);
                            ctx.stroke();
                            ctx.restore();
                         }
                    }


                    this.nodes.forEach(node => {
                        if (!node || typeof node.x !== 'number') return;
                        let tempShape = node.shape || NODE_DEFAULT_SHAPE;
                        let tempBorderStyle = node.borderStyle || 'solid';
                        let tempBorderWidth = node.borderWidth || 1;

                        if (this.previewConnectionSide && this.previewConnectionSide.nodeId === node.id) {
                            if (this.previewConnectionSide.property === 'shape') { tempShape = this.previewConnectionSide.value; }
                            else if (this.previewConnectionSide.property === 'borderStyle') { tempBorderStyle = this.previewConnectionSide.value; }
                            else if (this.previewConnectionSide.property === 'borderWidth') { tempBorderWidth = this.previewConnectionSide.value; }
                        }

                        const centerX = node.x + node.width / 2; const centerY = node.y + node.height / 2;
                        ctx.save();
                        let currentTransformScale = 1.0; let currentAlpha = 1.0;
                        if (node.isAppearing) { node.animationProgress = Math.min(1, (node.animationProgress || 0) + NODE_APPEAR_SPEED); currentTransformScale = 0.5 + node.animationProgress * 0.5; currentAlpha = node.animationProgress; if (node.animationProgress >= 1) { delete node.isAppearing; delete node.animationProgress; } ctx.translate(centerX, centerY); ctx.scale(currentTransformScale, currentTransformScale); ctx.translate(-centerX, -centerY); ctx.globalAlpha = currentAlpha; }
                        else if (node.id === this.hoveredNodeId && !this.isDragging && !this.isPanning && !this.isDraggingLink && !this.draggingConnectionEnd) { ctx.translate(centerX, centerY); ctx.scale(NODE_HOVER_SCALE, NODE_HOVER_SCALE); ctx.translate(-centerX, -centerY); }

                        let borderColor = ds.nodeDefaultBorderColor;
                        if (node.id === this.selectedNodeId) { borderColor = NODE_SELECTED_BORDER_COLOR; tempBorderWidth = Math.max(tempBorderWidth, 2); }
                        else if (node.id === this.potentialDropTargetId) { borderColor = NODE_DROP_TARGET_BORDER_COLOR; tempBorderWidth = Math.max(tempBorderWidth, 2); } // Node drag reparent
                        else if (node.id === this.potentialLinkTargetId) { borderColor = NODE_LINK_TARGET_BORDER_COLOR; tempBorderWidth = Math.max(tempBorderWidth, 2); } // Alt-drag linking
                        else if (this.draggingConnectionEnd && this.potentialEndPoint && node.id === this.potentialEndPoint.node.id && 
                                 (!this.draggingConnectionEnd.nodeToAttach || node.id !== this.draggingConnectionEnd.nodeToAttach.id)) {
                            borderColor = NODE_LINK_TARGET_BORDER_COLOR; // Highlight for connection endpoint drag to new node
                            tempBorderWidth = Math.max(tempBorderWidth, 2);
                        }

                        ctx.fillStyle = node.color || NODE_DEFAULT_BG_COLOR;
                        ctx.strokeStyle = borderColor;
                        ctx.lineWidth = tempBorderWidth / currentTransformScale;
                        const borderStyleObj = AVAILABLE_BORDER_STYLES.find(bs => bs.value === tempBorderStyle);
                        ctx.setLineDash(borderStyleObj ? borderStyleObj.dash.map(d => d * (ctx.lineWidth > 1 ? 1.5 : 1)) : []);

                        // Apply node-specific shadow properties or defaults
                        const shadowEnabled = node.shadowEnabled === undefined ? NODE_DEFAULT_SHADOW_ENABLED : node.shadowEnabled;
                        if (shadowEnabled) {
                            ctx.shadowColor = node.shadowColor || NODE_DEFAULT_SHADOW_COLOR;
                            ctx.shadowBlur = node.shadowBlur === undefined ? NODE_DEFAULT_SHADOW_BLUR : node.shadowBlur;
                            ctx.shadowOffsetX = node.shadowOffsetX === undefined ? NODE_DEFAULT_SHADOW_OFFSET_X : node.shadowOffsetX;
                            ctx.shadowOffsetY = node.shadowOffsetY === undefined ? NODE_DEFAULT_SHADOW_OFFSET_Y : node.shadowOffsetY;
                        } else {
                            ctx.shadowColor = 'transparent';
                            ctx.shadowBlur = 0;
                            ctx.shadowOffsetX = 0;
                            ctx.shadowOffsetY = 0;
                        }

                        if (tempShape === 'rectangle') drawRectangleNode(ctx, node);
                        else if (tempShape === 'ellipse') drawEllipseNode(ctx, node);
                        else if (tempShape === 'diamond') drawDiamondNode(ctx, node);
                        else if (tempShape === 'triangle') drawTriangleNode(ctx, node);
                        else drawRectangleNode(ctx, node);

                        ctx.setLineDash([]); ctx.shadowColor = 'transparent';
                        ctx.fillStyle = node.textColor || NODE_DEFAULT_TEXT_COLOR;
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        let currentIconX = node.x + 10;
                        const iconY = node.y + node.height / 2;
                        if (node.icon) { const faIcon = AVAILABLE_ICONS.find(i => i.class === node.icon); if (faIcon) { ctx.font = `900 ${ICON_SIZE}px "Font Awesome 6 Free"`; ctx.fillText(faIcon.unicode, currentIconX, iconY); currentIconX += ICON_SIZE + 5; } }
                        if (node.hyperlink) { ctx.font = `900 ${ICON_SIZE}px "Font Awesome 6 Free"`; const oldFill = ctx.fillStyle; ctx.fillStyle = '#60a5fa'; ctx.fillText(HYPERLINK_INDICATOR_UNICODE, currentIconX, iconY); ctx.fillStyle = oldFill; }
                        // Font setting is now primarily handled by wrapText
                        ctx.fillStyle = node.textColor || NODE_DEFAULT_TEXT_COLOR;
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

                        // Icon and Hyperlink indicator drawing (remains similar, ensure coordinates are correct)
                        let currentIconX = node.x + 10; // Standard left padding for icons
                        const iconY = node.y + node.height / 2;
                        if (node.icon) {
                            const faIcon = AVAILABLE_ICONS.find(i => i.class === node.icon);
                            if (faIcon) {
                                ctx.font = `900 ${ICON_SIZE}px "Font Awesome 6 Free"`; // Specific font for FA icons
                                ctx.fillText(faIcon.unicode, currentIconX, iconY);
                                currentIconX += ICON_SIZE + 5;
                            }
                        }
                        if (node.hyperlink) {
                            ctx.font = `900 ${ICON_SIZE}px "Font Awesome 6 Free"`; // Specific font for FA icons
                            const oldFill = ctx.fillStyle;
                            ctx.fillStyle = '#60a5fa';
                            ctx.fillText(HYPERLINK_INDICATOR_UNICODE, currentIconX, iconY);
                            ctx.fillStyle = oldFill;
                        }

                        // Text Drawing
                        // Font and fillStyle are set before icons, but wrapText will set node-specific font.
                        // Ensure fillStyle is set correctly before calling wrapText if it's not done inside.
                        ctx.fillStyle = node.textColor || NODE_DEFAULT_TEXT_COLOR; // Set text color before calling wrapText
                        wrapText(ctx, node); // Pass the whole node

                        if (node.imageUrl && node.imageObj) drawNodeImageIndicator(ctx, node, this.scale);
                        ctx.restore();
                    });

                    ctx.restore();
                    let stillAnimating = false; this.nodes.forEach(n => { if(n.isAppearing || n.isLinkAnimating) stillAnimating = true; });
                    if (stillAnimating && !this.isAnimating) this.startAnimationLoop();
                    else if (!stillAnimating && this.isAnimating) this.isAnimating = false;
                },
                showError(message, type = 'error', title) { this.errorModalTitle = title || (type === 'success' ? 'Succès' : (type === 'info' ? 'Information' : 'Erreur')); this.errorModalMessage = String(message || "Une erreur inconnue s'est produite."); this.errorModalType = type; this.isErrorModalOpen = true; },
                findNodeById(id) { return this.nodes.find(node => node.id === id); },
                getMousePos(e, canvasEl = this.$refs.mindMapCanvas) { if (!canvasEl) return { x: 0, y: 0, screenX: e.clientX, screenY: e.clientY }; const rect = canvasEl.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; return { x: (mx - this.offsetX) / this.scale, y: (my - this.offsetY) / this.scale, screenX: e.clientX, screenY: e.clientY }; },
                getNodeAtPos(worldX, worldY) { for (let i = this.nodes.length - 1; i >= 0; i--) { const n = this.nodes[i]; const shape = n.shape || NODE_DEFAULT_SHAPE; const { x, y, width, height } = n; if (shape === 'rectangle') { if (worldX >= x && worldX <= x + width && worldY >= y && worldY <= y + height) return n; } else if (shape === 'ellipse') { const cx = x + width / 2; const cy = y + height / 2; const rx = width / 2; const ry = height / 2; if (rx > 0 && ry > 0) { const dx = worldX - cx; const dy = worldY - cy; if ((dx * dx) / (rx * rx) + (dy * dy) / (ry * ry) <= 1) return n; } } else if (shape === 'diamond') { const p1 = { x: x + width / 2, y: y }; const p2 = { x: x + width, y: y + height / 2 }; const p3 = { x: x + width / 2, y: y + height }; const p4 = { x: x, y: y + height / 2 }; const d1 = (worldX - p1.x) * (p2.y - p1.y) - (worldY - p1.y) * (p2.x - p1.x); const d2 = (worldX - p2.x) * (p3.y - p2.y) - (worldY - p2.y) * (p3.x - p2.x); const d3 = (worldX - p3.x) * (p4.y - p3.y) - (worldY - p3.y) * (p4.x - p3.x); const d4 = (worldX - p4.x) * (p1.y - p4.y) - (worldY - p4.y) * (p1.x - p4.x); if ((d1 >= 0 && d2 >= 0 && d3 >= 0 && d4 >= 0) || (d1 <= 0 && d2 <= 0 && d3 <= 0 && d4 <= 0)) return n; } else if (shape === 'triangle') { const p1 = { x: x + width / 2, y: y }; const p2 = { x: x + width, y: y + height }; const p3 = { x: x, y: y + height }; const d1 = (worldX - p2.x) * (p1.y - p2.y) - (p1.x - p2.x) * (worldY - p2.y); const d2 = (worldX - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (worldY - p3.y); const d3 = (worldX - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (worldY - p1.y); const has_neg = (d1 < 0) || (d2 < 0) || (d3 < 0); const has_pos = (d1 > 0) || (d2 > 0) || (d3 > 0); if (!(has_neg && has_pos)) return n; } } return null; },
                isPositionOccupied(x, y, width, height, excludeNodeId) {
                    const margin = 5; // Reduced margin
                    const checkRect = { x: x - margin, y: y - margin, width: width + 2 * margin, height: height + 2 * margin };
                    for (const node of this.nodes) {
                        if (node.id === excludeNodeId) continue;
                        const nodeRect = { x: node.x, y: node.y, width: node.width, height: node.height };
                        if (checkRect.x < nodeRect.x + nodeRect.width &&
                            checkRect.x + checkRect.width > nodeRect.x &&
                            checkRect.y < nodeRect.y + nodeRect.height &&
                            checkRect.y + checkRect.height > nodeRect.y) {
                            return true;
                        }
                    }
                    return false;
                },
                resizeCanvas() {
                    const canvas = this.$refs.mindMapCanvas;
                    if (!canvas || !canvas.parentElement) return;

                    let availableWidth = canvas.parentElement.clientWidth;
                    // If sidebar is open and not in mobile view (where it's fixed overlay), subtract its width
                    if (this.isSidebarOpen && !this.isMobileView) {
                        const sidebarWidthPx = parseInt(SIDEBAR_WIDTH_DESKTOP, 10);
                        if (!isNaN(sidebarWidthPx)) {
                           availableWidth -= sidebarWidthPx;
                        }
                    }
                    // On mobile, if sidebar is open, canvas width should ideally be full parent width behind the overlay.
                    // Or, if parent is flex and sidebar is not 'fixed', then parent.clientWidth would already be correct.
                    // Current setup: sidebar is 'fixed' on mobile, 'relative' on sm+.
                    // So on sm+, parentElement.clientWidth will be (full_width - sidebar_width) if sidebar is part of flex flow.
                    // The current HTML structure makes the #propertiesSidebar fixed on mobile and part of flex flow on sm+
                    // The parent `div.flex-grow.m-2.relative...` is now a flex container. Canvas is a child.
                    // If sidebar is `sm:relative`, it will take space in flex row on sm+ screens.
                    // `canvas.parentElement.clientWidth` should be the width of the flex cell containing the canvas.
                    // Let's adjust the parent of canvas to be the direct flex item for clarity or ensure canvas itself is flex-grow.
                    // The canvas's direct parent is `div class="flex-grow m-2 relative overflow-hidden rounded-lg shadow-inner flex"`
                    // The canvas itself should be flex-grow if the sidebar is also a flex item in that container on desktop.
                    // The current CSS for sidebar: `sm:relative`. So on sm+, it's part of the flow.
                    // The canvas has `w-full h-full`. If its parent is the flex container, and sidebar is also there,
                    // `w-full` on canvas might try to take 100% of parent, conflicting with sidebar.
                    // Let's ensure canvas can shrink. Add `flex-shrink` and `flex-grow` to canvas, or let sidebar define its width and canvas take rest.

                    // The parent `div.flex-grow.m-2...` is ALREADY a flex container.
                    // Canvas has `w-full`. Sidebar has fixed width on desktop.
                    // So `availableWidth = canvas.parentElement.clientWidth;` is correct if canvas is the only other flex item that grows.
                    // It seems `canvas.parentElement.clientWidth` will be the space allocated to the canvas by the flex layout.
                    // So, this calculation might be simpler: `canvas.parentElement.clientWidth` IS the available width for canvas.
                    // The subtraction was an attempt to manually calculate, but flexbox should handle it if canvas can grow and shrink.
                    // Let's simplify resizeCanvas, assuming flexbox handles the parent width correctly.
                    // The key is that the parent of the canvas is a flex row, and the canvas can take up the available space.

                    const newWidth = Math.max(1, canvas.parentElement.clientWidth); // This should be correct if flex layout is right
                    const newHeight = Math.max(1, canvas.parentElement.clientHeight);

                    if (canvas.width !== newWidth || canvas.height !== newHeight) {
                        canvas.width = newWidth;
                        canvas.height = newHeight;
                        this.redrawCanvas();
                    }
                },
                handleResizeForSidebar() {
                    this.resizeCanvas();
                },
                toggleSidebar() {
                    const openingSidebar = !this.isSidebarOpen;
                    this.isSidebarOpen = openingSidebar;

                    if (openingSidebar) { // When opening sidebar
                        this.hideContextMenu(); // Also clears previewConnectionSide
                        if (this.fileMenu.visible) {
                            this.fileMenu.visible = false;
                        }
                    }
                    // Canvas resize logic needs to be aware of sidebar state, especially on desktop
                    this.$nextTick(() => {
                        this.resizeCanvas();
                    });
                },
                startAnimationLoop() {
                    if (this.isAnimating) return;
                    this.isAnimating = true;
                    const animateStep = () => {
                        let stillAnimatingThisFrame = false;
                        this.nodes.forEach(n => {
                            if (n.isAppearing || n.isLinkAnimating) {
                                stillAnimatingThisFrame = true;
                            }
                        });

                        if (stillAnimatingThisFrame) {
                            this.redrawCanvas();
                            requestAnimationFrame(animateStep);
                        } else {
                            this.isAnimating = false;
                            this.redrawCanvas();
                        }
                    };
                    requestAnimationFrame(animateStep);
                },
                prepareLinkAnimation(node) {
                   if (!node || node.parentId === null) return;
                   const parent = this.findNodeById(node.parentId);
                   if (parent && !node.isLinkAnimating) {
                       node.linkPrevP0 = this.getConnectionPointCoords(parent, node.parentExitPoint || 'auto');
                       node.linkPrevP3 = this.getConnectionPointCoords(node, node.entryPoint || 'auto');
                       node.linkAnimationStartTime = Date.now();
                       node.isLinkAnimating = true;
                       this.startAnimationLoop();
                   }
                },
                resetInteractionStates() {
                    this.isDragging = false;
                    this.isPanning = false;
                    this.draggedNodeId = null;
                    this.potentialDropTargetId = null;
                    this.draggingConnectionEnd = null;
                    this.potentialEndPoint = null;
                    this.cancelDragLinking();
                    this.potentialLinkTargetId = null;
                },
                addInitialNode() {
                    const canvas = this.$refs.mindMapCanvas;
                    if (!canvas || canvas.width <= 0 || canvas.height <= 0) {
                        this.$nextTick(() => this.addInitialNode());
                        return null;
                    }
                    const nodeId = generateUUID();
                    const nodeWidth = NODE_DEFAULT_WIDTH + 40;
                    const nodeHeight = NODE_DEFAULT_HEIGHT;
                    const nodeX = (canvas.width / 2) - nodeWidth / 2;
                    const nodeY = (canvas.height / 2) - nodeHeight / 2;
                    const worldX = (nodeX - this.offsetX) / this.scale;
                    const worldY = (nodeY - this.offsetY) / this.scale;

                    const newNode = {
                        id: nodeId, text: "Concept Central",
                        x: worldX, y: worldY, width: nodeWidth, height: nodeHeight,
                        parentId: null, color: '#4A5568', textColor: '#E2E8F0',
                        imageUrl: null, imageObj: null, connectionType: 'solid',
                        entryPoint: null, parentExitPoint: null, shape: NODE_DEFAULT_SHAPE,
                        icon: null, borderStyle: 'solid', borderWidth: 1, hyperlink: null,
                        isAppearing: true, animationProgress: 0
                    };
                    this.nodes.push(newNode);
                    this.selectedNodeId = nodeId;
                    this.startAnimationLoop();
                    this.recordHistory("Add Initial Node");
                    return newNode;
                },
                addRootNode() {
                    if (this.nodes.some(n => n.parentId === null)) {
                        this.showError("Un concept central existe déjà.");
                        return null;
                    }
                    const canvas = this.$refs.mindMapCanvas;
                    if (!canvas || canvas.width <= 0 || canvas.height <= 0) { return null; }
                    const rootId = generateUUID();
                    const nodeWidth = NODE_DEFAULT_WIDTH + 40;
                    const nodeHeight = NODE_DEFAULT_HEIGHT;
                    const rootX = (this.contextMenu.rawX !== 0 ? this.contextMenu.rawX : (canvas.width / 2 - this.offsetX) / this.scale) - nodeWidth / 2;
                    const rootY = (this.contextMenu.rawY !== 0 ? this.contextMenu.rawY : (canvas.height / 2 - this.offsetY) / this.scale) - nodeHeight / 2;
                    const newNode = { id: rootId, text: "Concept Central", x: rootX, y: rootY, width: nodeWidth, height: nodeHeight, parentId: null, color: '#4A5568', textColor: '#E2E8F0', imageUrl: null, imageObj: null, connectionType: 'solid', entryPoint: 'top', parentExitPoint: null, shape: NODE_DEFAULT_SHAPE, icon: null, borderStyle: 'solid', borderWidth: 1, hyperlink: null, isAppearing: true, animationProgress: 0 };
                    this.nodes.push(newNode);
                    this.selectedNodeId = rootId;
                    this.startAnimationLoop();
                    this.recordHistory("Add Root Node");
                    return newNode;
                },
                addNode(parentId = this.selectedNodeId) {
                    if (!parentId) { this.showError("Veuillez sélectionner un nœud parent."); return; }
                    const parentNode = this.findNodeById(parentId);
                    if (!parentNode) return;

                    const newNodeId = generateUUID();
                    const newNodeWidth = NODE_DEFAULT_WIDTH;
                    const newNodeHeight = NODE_DEFAULT_HEIGHT;

                    let newNodeX = 0;
                    let newNodeY = 0;

                    const potentialPositions = [
                        { x: parentNode.x + parentNode.width / 2 - newNodeWidth / 2, y: parentNode.y + parentNode.height + CHILD_NODE_SPACING }, // Bottom
                        { x: parentNode.x + parentNode.width + CHILD_NODE_SPACING, y: parentNode.y + parentNode.height / 2 - newNodeHeight / 2 }, // Right
                        { x: parentNode.x - newNodeWidth - CHILD_NODE_SPACING, y: parentNode.y + parentNode.height / 2 - newNodeHeight / 2 }, // Left
                        { x: parentNode.x + parentNode.width / 2 - newNodeWidth / 2, y: parentNode.y - newNodeHeight - CHILD_NODE_SPACING }, // Top
                        { x: parentNode.x + parentNode.width + CHILD_NODE_SPACING, y: parentNode.y + parentNode.height + CHILD_NODE_SPACING }, // Bottom-Right
                        { x: parentNode.x - newNodeWidth - CHILD_NODE_SPACING, y: parentNode.y + parentNode.height + CHILD_NODE_SPACING }, // Bottom-Left
                        { x: parentNode.x + parentNode.width + CHILD_NODE_SPACING, y: parentNode.y - newNodeHeight - CHILD_NODE_SPACING }, // Top-Right
                        { x: parentNode.x - newNodeWidth - CHILD_NODE_SPACING, y: parentNode.y - newNodeHeight - CHILD_NODE_SPACING }, // Top-Left
                    ];

                    let positionFound = false;
                    for (const pos of potentialPositions) {
                        if (!this.isPositionOccupied(pos.x, pos.y, newNodeWidth, newNodeHeight, parentId)) {
                            newNodeX = pos.x;
                            newNodeY = pos.y;
                            positionFound = true;
                            break;
                        }
                    }

                    if (!positionFound) {
                         newNodeX = parentNode.x + parentNode.width / 2 - newNodeWidth / 2;
                         newNodeY = parentNode.y + parentNode.height + CHILD_NODE_SPACING * 2; // Fallback further below
                    }


                    const tempNewNodeForCalc = { x: newNodeX, y: newNodeY, width: newNodeWidth, height: newNodeHeight };
                    const { parentExitPoint, entryPoint } = this.calculateDefaultConnectionPoints(parentNode, tempNewNodeForCalc); // This is fine for immediate drawing, but node stores null.
                    const newNode = { id: newNodeId, text: "Nouveau Nœud", x: newNodeX, y: newNodeY, width: newNodeWidth, height: newNodeHeight, parentId: parentNode.id, color: NODE_DEFAULT_BG_COLOR, textColor: NODE_DEFAULT_TEXT_COLOR, imageUrl: null, imageObj: null, connectionType: 'solid', entryPoint: null, parentExitPoint: null, shape: NODE_DEFAULT_SHAPE, icon: null, borderStyle: 'solid', borderWidth: 1, hyperlink: null, isAppearing: true, animationProgress: 0 };
                    this.nodes.push(newNode);
                    this.selectedNodeId = newNodeId;
                    this.startAnimationLoop();
                    this.hideContextMenu();
                    this.recordHistory("Add Node");
                },
                addNodeAtPosition(worldX, worldY) {
                    const newNodeId = generateUUID();
                    const newNode = { id: newNodeId, text: "Nouveau Nœud", x: worldX - NODE_DEFAULT_WIDTH / 2, y: worldY - NODE_DEFAULT_HEIGHT / 2, width: NODE_DEFAULT_WIDTH, height: NODE_DEFAULT_HEIGHT, parentId: null, color: NODE_DEFAULT_BG_COLOR, textColor: NODE_DEFAULT_TEXT_COLOR, imageUrl: null, imageObj: null, connectionType: 'solid', entryPoint: null, parentExitPoint: null, shape: NODE_DEFAULT_SHAPE, icon: null, borderStyle: 'solid', borderWidth: 1, hyperlink: null, isAppearing: true, animationProgress: 0 };
                    
                    // Removed the check: if (newNode.parentId === null && this.hasRootNode)

                    this.nodes.push(newNode);
                    this.selectedNodeId = newNodeId;
                    this.startAnimationLoop();
                    this.hideContextMenu();
                    this.recordHistory("Add Node at Position");
                },
                openTextEditModal(nodeIdToEdit = this.selectedNodeId) { if (!nodeIdToEdit) { this.showError("Sélectionnez un nœud pour modifier son texte."); return; } const node = this.findNodeById(nodeIdToEdit); if (node) { this.nodeToEditTextId = node.id; this.nodeTextInput = node.text; this.isTextEditModalOpen = true; this.$nextTick(() => { this.$refs.nodeTextInputArea?.focus(); }); this.hideContextMenu(); } },
                saveNodeText() {
                    if (this.nodeToEditTextId) {
                        const node = this.findNodeById(this.nodeToEditTextId);
                        if (node) {
                            const oldText = node.text;
                            const newText = this.nodeTextInput;
                            if (oldText !== newText) {
                                node.text = newText;
                                const dimensions = this.calculateNodeDimensions(node, newText); // Use new method
                                node.width = dimensions.width;
                                node.height = dimensions.height;
                                this.recordHistory("Edit Node Text & Dimensions");
                            }
                        }
                    }
                    this.isTextEditModalOpen = false;
                    this.nodeToEditTextId = null;
                },
                calculateNodeDimensions(node, text) { // Renamed and updated logic
                    const canvas = this.$refs.mindMapCanvas;
                    const ctx = canvas ? canvas.getContext('2d') : null;
                    if (!ctx) return { width: NODE_DEFAULT_WIDTH, height: NODE_DEFAULT_HEIGHT };

                    const currentPadding = node.padding === undefined ? NODE_DEFAULT_PADDING : node.padding;
                    const currentFontSize = node.fontSize || NODE_DEFAULT_FONT_SIZE;
                    const currentFontFamily = node.fontFamily || NODE_DEFAULT_FONT_FAMILY;
                    const lineHeight = currentFontSize * NODE_TEXT_LINE_HEIGHT_RATIO;

                    ctx.font = `${currentFontSize}px ${currentFontFamily}`;

                    const textToMeasure = String(text || ""); // Ensure text is a string
                    const textLines = textToMeasure.split('\n');
                    let maxTextLineWidth = 0;
                    textLines.forEach(line => {
                        const tw = ctx.measureText(line).width;
                        if (tw > maxTextLineWidth) maxTextLineWidth = tw;
                    });

                    const numberOfLines = textLines.length || 1;

                    // Calculate combined width of icons and their padding
                    let iconOffsetTotalWidth = 0;
                    if (node.icon) iconOffsetTotalWidth += ICON_SIZE + 5; // 5 is icon's own padding
                    if (node.hyperlink) iconOffsetTotalWidth += ICON_SIZE + 5; // 5 is icon's own padding
                    // Ensure there's some spacing even if only one icon, or if icons are stacked vs side-by-side
                    // Current wrapText logic implies they are side-by-side and iconOffsetLeft accumulates.
                    // This calculation assumes icons are to the left of text block.

                    const contentWidth = maxTextLineWidth;
                    const contentHeight = numberOfLines * lineHeight;

                    const calculatedWidth = contentWidth + (currentPadding * 2) + iconOffsetTotalWidth;
                    const calculatedHeight = contentHeight + (currentPadding * 2);

                    return {
                        width: Math.max(MIN_NODE_WIDTH, Math.min(calculatedWidth, MAX_NODE_WIDTH)),
                        height: Math.max(MIN_NODE_HEIGHT, Math.min(calculatedHeight, MAX_NODE_HEIGHT))
                    };
                },
                updateNodePadding(value) {
                    if (!this.selectedNode) return;
                    const newPadding = (isNaN(value) || value < 0) ? NODE_DEFAULT_PADDING : Math.min(value, 50); // Max padding 50 as per input max

                    this.selectedNode.padding = newPadding;
                    const dimensions = this.calculateNodeDimensions(this.selectedNode, this.selectedNode.text);
                    this.selectedNode.width = dimensions.width;
                    this.selectedNode.height = dimensions.height;

                    this.recordHistory(`Set Node Padding to ${newPadding}`);
                    this.redrawCanvas();
                },
                requestDeleteNode(nodeId = this.selectedNodeId) { this.hideContextMenu(); if (!nodeId) { this.showError("Sélectionnez un nœud à supprimer."); return; } this.nodeToDeleteId = nodeId; this.isDeleteConfirmModalOpen = true; },
                confirmDeleteNode() {
                    if (!this.nodeToDeleteId) return;
                    const getSubtreeIds = (pId) => { let ids = []; const children = this.nodes.filter(node => node.parentId === pId); children.forEach(child => { ids.push(child.id); ids = ids.concat(getSubtreeIds(child.id)); }); return ids; };
                    const idsToRemove = getSubtreeIds(this.nodeToDeleteId); idsToRemove.push(this.nodeToDeleteId);
                    this.nodes = this.nodes.filter(node => !idsToRemove.includes(node.id));
                    if (idsToRemove.includes(this.selectedNodeId)) this.selectedNodeId = null;
                    if (idsToRemove.includes(this.nodeToEditTextId)) { this.isTextEditModalOpen = false; this.nodeToEditTextId = null; }
                    if (this.hoveredNodeId && idsToRemove.includes(this.hoveredNodeId)) this.hoveredNodeId = null;
                    if (this.potentialDropTargetId && idsToRemove.includes(this.potentialDropTargetId)) this.potentialDropTargetId = null;
                    if (this.potentialLinkTargetId && idsToRemove.includes(this.potentialLinkTargetId)) this.potentialLinkTargetId = null;
                    this.nodeToDeleteId = null; this.isDeleteConfirmModalOpen = false;
                    this.recordHistory("Delete Node");
                },
                // This replaces handleNodeBgColorChange and handleNodeTextColorChange
                updateNodeProperty(propertyKey, value) {
                    if (this.selectedNode) {
                        const node = this.selectedNode; // Alias for clarity
                        if (node[propertyKey] !== value) {
                            // const oldValue = node[propertyKey]; // Not strictly needed for history payload unless undoing requires old value for complex logic beyond simple set
                            node[propertyKey] = value;

                            if (propertyKey === 'fontSize' || propertyKey === 'fontFamily') {
                                const dimensions = this.calculateNodeDimensions(node, node.text);
                                node.width = dimensions.width;
                                node.height = dimensions.height;
                                this.recordHistory(`Set Node ${propertyKey} (and dimensions)`);
                            } else {
                                // For other properties like color, borderStyle, etc., that don't affect dimensions through calculateNodeDimensions
                                this.recordHistory(`Set Node ${propertyKey} to ${value}`);
                            }
                            this.redrawCanvas();
                        }
                    }
                },
                triggerImageUpload(nodeId = this.selectedNodeId) { this.hideContextMenu(); if (!nodeId) { this.showError("Sélectionnez un nœud pour ajouter une image."); return; } const node = this.findNodeById(nodeId); if (node) { this.$refs.imageInput.dataset.nodeId = nodeId; this.$refs.imageInput.click(); } },
                handleImageSelected(event) { const file = event.target.files[0]; const nodeIdToUpdate = event.target.dataset.nodeId; if (file && nodeIdToUpdate) { const reader = new FileReader(); reader.onload = (e_reader) => { const img = new Image(); img.onload = () => { const node = this.findNodeById(nodeIdToUpdate); if (node) { if (node.imageUrl && node.imageUrl.startsWith('blob:')) URL.revokeObjectURL(node.imageUrl); node.imageUrl = img.src; node.imageObj = img; this.recordHistory("Add/Change Node Image"); this.redrawCanvas(); } }; img.onerror = () => { this.showError("Erreur lors du chargement de l'image."); const node = this.findNodeById(nodeIdToUpdate); if(node) {node.imageUrl = null; node.imageObj = null;} this.redrawCanvas(); }; img.src = e_reader.target.result; }; reader.onerror = () => this.showError("Erreur lors de la lecture du fichier image."); reader.readAsDataURL(file); } event.target.value = ''; if (event.target.dataset.nodeId) delete event.target.dataset.nodeId; },

                handleNodeBgImageSelected(event) {
                    const file = event.target.files[0];
                    if (!file || !this.selectedNodeId) {
                        event.target.value = '';
                        return;
                    }
                    const nodeToUpdate = this.findNodeById(this.selectedNodeId);
                    if (!nodeToUpdate) {
                        event.target.value = '';
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e_reader) => {
                        const img = new Image();
                        img.onload = () => {
                            if (nodeToUpdate.nodeBgImageUrl && nodeToUpdate.nodeBgImageUrl.startsWith('blob:')) {
                                URL.revokeObjectURL(nodeToUpdate.nodeBgImageUrl);
                            }
                            nodeToUpdate.nodeBgImageUrl = img.src; // Using Data URL from reader result
                            nodeToUpdate.nodeBgImageObj = img;
                            this.recordHistory("Set Node Background Image");
                            this.redrawCanvas();
                        };
                        img.onerror = () => {
                            this.showError("Erreur lors du chargement de l'image de fond du nœud.");
                            // Potentially clear if there was an old image that failed to be replaced
                            // nodeToUpdate.nodeBgImageUrl = null;
                            // nodeToUpdate.nodeBgImageObj = null;
                            this.redrawCanvas();
                        };
                        img.src = e_reader.target.result;
                    };
                    reader.onerror = () => {
                        this.showError("Erreur lors de la lecture du fichier image de fond.");
                    };
                    reader.readAsDataURL(file);
                    event.target.value = ''; // Clear file input
                },
                removeNodeBgImage(nodeId) {
                    if (!nodeId) nodeId = this.selectedNodeId;
                    const node = this.findNodeById(nodeId);
                    if (node && node.nodeBgImageUrl) {
                        if (node.nodeBgImageUrl.startsWith('blob:')) {
                             URL.revokeObjectURL(node.nodeBgImageUrl);
                        }
                        node.nodeBgImageUrl = null;
                        node.nodeBgImageObj = null;
                        this.recordHistory("Remove Node Background Image");
                        this.redrawCanvas();
                    }
                },

                showImagePreview(imageUrl) { this.previewImageUrl = imageUrl; this.isImagePreviewModalOpen = true; },
                openHyperlinkModal(nodeId = this.selectedNodeId) { this.hideContextMenu(); if (!nodeId) { this.showError("Sélectionnez un nœud pour ajouter un lien."); return; } const node = this.findNodeById(nodeId); if (node) { this.nodeToEditHyperlinkId = nodeId; this.hyperlinkInput = node.hyperlink || ''; this.isHyperlinkModalOpen = true; } },
                saveNodeHyperlink() { if (this.nodeToEditHyperlinkId) { const node = this.findNodeById(this.nodeToEditHyperlinkId); if (node) { const newLink = this.hyperlinkInput.trim(); if (node.hyperlink !== newLink) { node.hyperlink = newLink || null; this.recordHistory("Add/Edit Hyperlink"); } } } this.isHyperlinkModalOpen = false; this.nodeToEditHyperlinkId = null; },
                setNodeProperty(nodeId, property, value) {
                    const node = this.findNodeById(nodeId);
                    let propertyChanged = false;
                    if (node) {
                        if (property === 'entryPoint' && node.parentId) {
                            const newEntryPointToSet = (value === 'auto') ? null : value;
                            if (node.entryPoint !== newEntryPointToSet) {
                                this.prepareLinkAnimation(node);
                                node.entryPoint = newEntryPointToSet;
                                if (newEntryPointToSet !== null) {
                                    const parentNode = this.findNodeById(node.parentId);
                                    if (parentNode) {
                                        const { parentExitPoint: newParentExit } = this.calculateDefaultConnectionPoints(parentNode, node);
                                        node.parentExitPoint = newParentExit;
                                    }
                                }
                                // Else: if newEntryPointToSet is null (auto), parentExitPoint remains as is.
                                propertyChanged = true;
                            }
                        } else if (property === 'parentExitPoint' && node.parentId) {
                            const newParentExitPointToSet = (value === 'auto') ? null : value;
                            if (node.parentExitPoint !== newParentExitPointToSet) {
                                this.prepareLinkAnimation(node);
                                node.parentExitPoint = newParentExitPointToSet;
                                if (newParentExitPointToSet !== null) {
                                    const parentNode = this.findNodeById(node.parentId);
                                    if (parentNode) {
                                        const { entryPoint: newEntryPoint } = this.calculateDefaultConnectionPoints(parentNode, node);
                                        node.entryPoint = newEntryPoint;
                                    }
                                }
                                // Else: if newParentExitPointToSet is null (auto), entryPoint remains as is.
                                propertyChanged = true;
                            }
                        } else if (node[property] !== value) { // For other properties or if not a link property with a parent
                            if (property === 'connectionType' && node.parentId) { // Also animate for connection type change
                                this.prepareLinkAnimation(node);
                            }
                            node[property] = value;
                            propertyChanged = true;
                        }
                    }
                    this.clearPreviewConnectionSide();
                    this.hideContextMenu();
                    if (propertyChanged) { this.recordHistory(`Set Node Property: ${property} to ${value}`); } // RedrawCanvas will be triggered by watcher or animation loop
                },
                detachNode(nodeId) {
                    const node = this.findNodeById(nodeId);
                    if (node && node.parentId !== null) {
                        node.parentId = null;
                        node.parentExitPoint = null;
                        if (node.isLinkAnimating) {
                            node.isLinkAnimating = false;
                            delete node.linkPrevP0;
                            delete node.linkPrevP3;
                            delete node.linkAnimationStartTime;
                        }
                        this.recordHistory("Detach Node");
                    }
                    this.hideContextMenu();
                },
                startLinking(nodeId) { this.hideContextMenu(); const node = this.findNodeById(nodeId); if (node) { this.isLinking = true; this.linkStartNodeId = nodeId; this.showError("Cliquez sur le nœud que vous voulez définir comme nouveau parent.", "info"); } },
                cancelLinking() { this.isLinking = false; this.linkStartNodeId = null; },
                cancelDragLinking() { this.isDraggingLink = false; this.linkDragStartNodeId = null; this.linkDragEndPos = null; this.potentialLinkTargetId = null; },
                handleMouseDown(e) {
                    const contextMenuEl = this.$refs.contextMenuElement;
                    if (this.contextMenu.visible && (!contextMenuEl || !contextMenuEl.contains(e.target))) {
                        this.hideContextMenu();
                    }
                    const fileMenuEl = this.$refs.fileMenuElement;
                    const fileMenuButtonEl = this.$refs.fileMenuButton;
                    if (this.fileMenu.visible) {
                        let clickedRelevantFileMenuPart = false;
                        if (fileMenuButtonEl && fileMenuButtonEl.contains(e.target)) { clickedRelevantFileMenuPart = true; }
                        else if (fileMenuEl && fileMenuEl.contains(e.target)) { clickedRelevantFileMenuPart = true; }
                        if (!clickedRelevantFileMenuPart) { this.fileMenu.visible = false; }
                    }

                    const pos = this.getMousePos(e); this.lastMousePos = { clientX: e.clientX, clientY: e.clientY };
                    const clickedConnEnd = this.getClickedConnectionEnd(pos);
                    if (clickedConnEnd) { this.draggingConnectionEnd = clickedConnEnd; this.isDragging = false; this.isPanning = false; this.draggedNodeId = null; this.potentialDropTargetId = null; this.isDraggingLink = false; this.$refs.mindMapCanvas.style.cursor = 'move'; return; }
                    if (this.isLinking) { e.stopPropagation(); const clickedNode = this.getNodeAtPos(pos.x, pos.y); const childNode = this.findNodeById(this.linkStartNodeId); if (clickedNode && childNode && clickedNode.id !== childNode.id && !this.isAncestor(childNode.id, clickedNode.id)) { const calculatedPoints = this.calculateDefaultConnectionPoints(clickedNode, childNode); childNode.parentId = clickedNode.id; childNode.parentExitPoint = calculatedPoints.parentExitPoint; if (!childNode.entryPoint || childNode.entryPoint === 'auto') { childNode.entryPoint = calculatedPoints.entryPoint; } this.recordHistory("Link Node (Context Menu)"); } else if (clickedNode) { this.showError("Connexion invalide (ex: connexion à soi-même ou à un descendant)."); } this.cancelLinking(); return; }
                    const clickedImageIndicatorNode = this.getNodeWithImageIndicatorClick(pos.x, pos.y); 
                    if (clickedImageIndicatorNode) { 
                        this.showImagePreview(clickedImageIndicatorNode.imageUrl); 
                        this.resetInteractionStates(); // Ensure other interactions are cleared
                        return; 
                    }
                    const clickedNodeForLink = this.getNodeAtPos(pos.x, pos.y);
                    if (e.altKey && clickedNodeForLink) { this.isDraggingLink = true; this.linkDragStartNodeId = clickedNodeForLink.id; this.linkDragEndPos = pos; this.resetInteractionStates(); this.isDraggingLink = true; this.linkDragStartNodeId = clickedNodeForLink.id; this.linkDragEndPos = pos; return; }
                    this.dragStart = pos; const clickedNode = this.getNodeAtPos(pos.x, pos.y);
                    if (clickedNode) {
                        this.isDragging = true; this.draggedNodeId = clickedNode.id;
                        if (this.selectedNodeId !== clickedNode.id) this.selectedNodeId = clickedNode.id;

                        const draggedNode = this.findNodeById(this.draggedNodeId);
                        if (draggedNode) {
                            // Freeze dragged node's own entry point if it's auto and has a parent
                            if (draggedNode.parentId !== null && draggedNode.entryPoint === null) {
                                const parentOfDragged = this.findNodeById(draggedNode.parentId);
                                if (parentOfDragged) {
                                    const dp = this.calculateDefaultConnectionPoints(parentOfDragged, draggedNode);
                                    draggedNode._frozenEntryPoint = dp.entryPoint;
                                }
                            }

                            // Freeze entry points of children if they are auto
                            this.nodes.forEach(node => {
                                if (node.parentId === draggedNode.id && node.entryPoint === null) {
                                    const dp = this.calculateDefaultConnectionPoints(draggedNode, node);
                                    node._frozenEntryPoint = dp.entryPoint;
                                }
                            });

                            // Freeze exit point on parent if it's auto for the connection to the dragged node
                            if (draggedNode.parentId !== null) {
                                const parentNode = this.findNodeById(draggedNode.parentId);
                                if (parentNode) {
                                    // parentExitPoint on the child (draggedNode) refers to the exit side on the parentNode
                                    if (draggedNode.parentExitPoint === null) {
                                        const dp = this.calculateDefaultConnectionPoints(parentNode, draggedNode);
                                        // We need a way to store this frozen exit ON the parent, but specific to this link.
                                        // Since parentExitPoint is stored on the child, we'll temporarily store it on the child for lookup during redraw.
                                        draggedNode._frozenParentExitPointOnParent = dp.parentExitPoint;
                                    }
                                }
                            }
                        }
                    }
                    else { this.isPanning = true; this.panStart = { x: e.clientX - this.offsetX, y: e.clientY - this.offsetY }; this.$refs.mindMapCanvas.style.cursor = 'grabbing'; if (this.selectedNodeId !== null) this.selectedNodeId = null; }
                },
                handleMouseMove(e) {
                    const pos = this.getMousePos(e);
                    this.lastMousePos = { clientX: e.clientX, clientY: e.clientY };
                    if (this.isLinking) { return; }
                    let newCursor = this.$refs.mindMapCanvas.style.cursor || 'grab';
                    this.potentialLinkTargetId = null; // Clear alt-drag target unless alt-dragging
                    this.potentialDropTargetId = null; // Clear node-drag target unless node-dragging

                    if (this.isDraggingLink) { 
                        this.linkDragEndPos = pos; 
                        const currentPotentialTarget = this.getNodeAtPos(pos.x, pos.y); 
                        let newPotentialLinkTargetId = null; 
                        if (currentPotentialTarget && currentPotentialTarget.id !== this.linkDragStartNodeId && !this.isAncestor(this.linkDragStartNodeId, currentPotentialTarget.id)) { 
                            newPotentialLinkTargetId = currentPotentialTarget.id; 
                        } 
                        this.potentialLinkTargetId = newPotentialLinkTargetId; 
                    } else if (this.draggingConnectionEnd) {
                        const draggedLinkOriginalChild = this.findNodeById(this.draggingConnectionEnd.childId);
                        const draggedLinkOriginalParent = this.findNodeById(draggedLinkOriginalChild.parentId);
                        let newHoveredNodeForEndpoint = this.getNodeAtPos(pos.x, pos.y);
                        let finalNodeForSideCalc;
                        let isValidNewTarget = false;

                        if (newHoveredNodeForEndpoint) {
                            if (this.draggingConnectionEnd.endType === 'parentExit') { // Dragging parent-side endpoint
                                if (newHoveredNodeForEndpoint.id !== draggedLinkOriginalChild.id &&
                                    !this.isAncestor(draggedLinkOriginalChild.id, newHoveredNodeForEndpoint.id)) {
                                    isValidNewTarget = true;
                                }
                            } else { // 'childEntry', dragging child-side endpoint
                                if (newHoveredNodeForEndpoint.id !== draggedLinkOriginalParent.id &&
                                    !this.isAncestor(draggedLinkOriginalParent.id, newHoveredNodeForEndpoint.id)) {
                                    isValidNewTarget = true;
                                }
                            }
                        }
                        finalNodeForSideCalc = isValidNewTarget ? newHoveredNodeForEndpoint : this.draggingConnectionEnd.nodeToAttach;
                        
                        let closestSide = null; let minDistSq = Infinity; let tempCoords = null;
                        CONNECTION_POINTS.forEach(side => {
                            const sideCoords = this.getConnectionPointCoords(finalNodeForSideCalc, side);
                            const distSq = (pos.x - sideCoords.x) ** 2 + (pos.y - sideCoords.y) ** 2;
                            if (distSq < minDistSq) { minDistSq = distSq; closestSide = side; tempCoords = sideCoords; }
                        });
                        this.potentialEndPoint = { node: finalNodeForSideCalc, side: closestSide, coords: tempCoords };
                        newCursor = 'move';
                    }
                    else if (this.isDragging && this.draggedNodeId) {
                        const draggedNode = this.findNodeById(this.draggedNodeId);
                        if (draggedNode) {
                            const dx = (pos.x - this.dragStart.x);
                            const dy = (pos.y - this.dragStart.y);

                            this.prepareLinkAnimation(draggedNode);
                            this.nodes.forEach(n => {
                                if (n.parentId === draggedNode.id) {
                                    this.prepareLinkAnimation(n);
                                }
                            });

                            draggedNode.x += dx;
                            draggedNode.y += dy;
                            this.dragStart = pos;
                        }
                        let currentPotentialTarget = null; let minDistanceSq = Infinity; const thresholdSq = (REPARENT_PROXIMITY_THRESHOLD / this.scale) ** 2; this.nodes.forEach(targetNode => { if (targetNode.id === this.draggedNodeId) return; const targetCenterX = targetNode.x + targetNode.width / 2; const targetCenterY = targetNode.y + targetNode.height / 2; const distSq = (pos.x - targetCenterX) ** 2 + (pos.y - targetCenterY) ** 2; if (distSq < minDistanceSq && distSq <= thresholdSq) { const draggedNodeData = this.findNodeById(this.draggedNodeId); if (draggedNodeData && targetNode.id !== draggedNodeData.parentId && !this.isAncestor(this.draggedNodeId, targetNode.id)) { minDistanceSq = distSq; currentPotentialTarget = targetNode.id; } } }); if (this.potentialDropTargetId !== currentPotentialTarget) this.potentialDropTargetId = currentPotentialTarget;
                        this.potentialDropTargetId = currentPotentialTarget;
                    }
                    else if (this.isPanning) { this.offsetX = e.clientX - this.panStart.x; this.offsetY = e.clientY - this.panStart.y; }
                    else { const nodeOver = this.getNodeAtPos(pos.x, pos.y); this.hoveredNodeId = nodeOver ? nodeOver.id : null; if (nodeOver) newCursor = 'pointer'; else newCursor = 'grab'; const connOver = this.getHoveredConnectionId(pos); this.hoveredConnectionId = connOver; if (connOver) newCursor = 'pointer'; if (this.getClickedConnectionEnd(pos)) newCursor = 'move'; else if (this.getNodeWithImageIndicatorClick(pos.x, pos.y)) newCursor = 'pointer'; }
                    if (this.$refs.mindMapCanvas.style.cursor !== newCursor && !this.isDraggingLink && !this.isPanning && !this.isDragging) { this.$refs.mindMapCanvas.style.cursor = newCursor; }
                },
                handleMouseUp(e) {
                    const wasDragging = this.isDragging; let stateChanged = false;
                    
                    if (this.isDraggingLink) {
                        const sourceNode = this.findNodeById(this.linkDragStartNodeId);
                        if (sourceNode) {
                            if (this.potentialLinkTargetId) {
                                const targetNode = this.findNodeById(this.potentialLinkTargetId);
                                if (targetNode && sourceNode.id !== targetNode.id && !this.isAncestor(sourceNode.id, targetNode.id)) {
                                    if(sourceNode.parentId !== targetNode.id) {
                                        this.prepareLinkAnimation(sourceNode);
                                        const { parentExitPoint, entryPoint } = this.calculateDefaultConnectionPoints(targetNode, sourceNode);
                                        sourceNode.parentId = targetNode.id; sourceNode.parentExitPoint = parentExitPoint; sourceNode.entryPoint = entryPoint;
                                        stateChanged = true;
                                    }
                                }
                            } else if (this.linkDragEndPos) {
                                const newNodeId = generateUUID();
                                const newNodeX = this.linkDragEndPos.x - NODE_DEFAULT_WIDTH / 2;
                                const newNodeY = this.linkDragEndPos.y - NODE_DEFAULT_HEIGHT / 2;
                                const tempNewNodeForCalc = { x: newNodeX, y: newNodeY, width: NODE_DEFAULT_WIDTH, height: NODE_DEFAULT_HEIGHT };
                                const { parentExitPoint, entryPoint } = this.calculateDefaultConnectionPoints(sourceNode, tempNewNodeForCalc); // For immediate drawing context
                                const newNode = { id: newNodeId, text: "Nouveau Nœud", x: newNodeX, y: newNodeY, width: NODE_DEFAULT_WIDTH, height: NODE_DEFAULT_HEIGHT, parentId: sourceNode.id, color: NODE_DEFAULT_BG_COLOR, textColor: NODE_DEFAULT_TEXT_COLOR, imageUrl: null, imageObj: null, connectionType: 'solid', entryPoint: null, parentExitPoint: null, shape: NODE_DEFAULT_SHAPE, icon: null, borderStyle: 'solid', borderWidth: 1, hyperlink: null, isAppearing: true, animationProgress: 0 };
                                this.nodes.push(newNode);
                                this.selectedNodeId = newNodeId;
                                this.startAnimationLoop();
                                stateChanged = true;
                            }
                        }
                        this.cancelDragLinking();

                    } else if (this.draggingConnectionEnd && this.potentialEndPoint) {
                        const linkedChildNode = this.findNodeById(this.draggingConnectionEnd.childId); // This is C
                        const originalParentNode = this.findNodeById(linkedChildNode.parentId);    // This is P
                        const newEndpointNode = this.potentialEndPoint.node; // This is P' or C'
                        const newEndpointSide = this.potentialEndPoint.side;

                        if (this.draggingConnectionEnd.endType === 'parentExit') { // Dragged parent-side of link P->C
                            // newEndpointNode is the new parent P'. newEndpointSide is the exit point on P'.
                            const newParentCandidate = newEndpointNode;
                            if (newParentCandidate.id !== originalParentNode.id || linkedChildNode.parentExitPoint !== newEndpointSide) {
                                this.prepareLinkAnimation(linkedChildNode);
                                linkedChildNode.parentId = newParentCandidate.id;
                                linkedChildNode.parentExitPoint = newEndpointSide; // Exit point on newParentCandidate
                                const { entryPoint: newChildEntryPoint } = this.calculateDefaultConnectionPoints(newParentCandidate, linkedChildNode);
                                linkedChildNode.entryPoint = newChildEntryPoint; // Entry point on linkedChildNode (C)
                                stateChanged = true;
                            }
                        } else { // 'childEntry', dragged child-side of link P->C
                            // newEndpointNode is the new child C'. newEndpointSide is the entry point on C'.
                            const newChildCandidate = newEndpointNode;

                            if (newChildCandidate.id !== linkedChildNode.id) { // Re-wiring P to a new child C'
                                this.prepareLinkAnimation(newChildCandidate); // Animate C'
                                newChildCandidate.parentId = originalParentNode.id;
                                newChildCandidate.entryPoint = newEndpointSide; // Entry point on C'
                                const { parentExitPoint: newParentExitForCPrime } = this.calculateDefaultConnectionPoints(originalParentNode, newChildCandidate);
                                newChildCandidate.parentExitPoint = newParentExitForCPrime; // Exit point on P for link to C'

                                if (linkedChildNode.parentId === originalParentNode.id) { // Detach original child C
                                    this.prepareLinkAnimation(linkedChildNode);
                                    linkedChildNode.parentId = null;
                                    linkedChildNode.parentExitPoint = null;
                                }
                                stateChanged = true;
                            } else { // Just changing entry point on the same child C (newChildCandidate.id === linkedChildNode.id)
                                if (linkedChildNode.entryPoint !== newEndpointSide) {
                                    this.prepareLinkAnimation(linkedChildNode);
                                    linkedChildNode.entryPoint = newEndpointSide; // New entry point on C
                                    const { parentExitPoint: newParentExitForC } = this.calculateDefaultConnectionPoints(originalParentNode, linkedChildNode);
                                    linkedChildNode.parentExitPoint = newParentExitForC; // Recalculate exit point on P for link to C
                                    stateChanged = true;
                                    }
                            }
                        }
                    } else if (wasDragging && this.draggedNodeId && this.potentialDropTargetId) { // Node drag reparenting
                        const draggedNode = this.findNodeById(this.draggedNodeId);
                        const targetNode = this.findNodeById(this.potentialDropTargetId);
                        if (draggedNode && targetNode && draggedNode.id !== targetNode.id && draggedNode.parentId !== targetNode.id && !this.isAncestor(draggedNode.id, targetNode.id)) {
                            this.prepareLinkAnimation(draggedNode);
                            const calculatedPoints = this.calculateDefaultConnectionPoints(targetNode, draggedNode);
                            draggedNode.parentId = targetNode.id; draggedNode.parentExitPoint = calculatedPoints.parentExitPoint;
                            if(!draggedNode.entryPoint || draggedNode.entryPoint === 'auto') { draggedNode.entryPoint = calculatedPoints.entryPoint; }
                            stateChanged = true;
                        }
                    }
                    if (wasDragging && this.draggedNodeId && !this.potentialDropTargetId) { stateChanged = true; }
                    
                    // Clear frozen points after drag operation
                    if (wasDragging || this.isDraggingLink || this.draggingConnectionEnd) { // Clear if any drag type occurred
                        this.nodes.forEach(node => {
                            delete node._frozenEntryPoint;
                            delete node._frozenParentExitPointOnParent;
                        });
                    }

                    this.resetInteractionStates();

                    if (stateChanged) {
                        this.recordHistory(this.draggingConnectionEnd ? "Modify Link Attachment" : "Node Interaction/Move");
                    }
                    this.draggingConnectionEnd = null; // Ensure reset after use
                    this.potentialEndPoint = null;     // Ensure reset
                    const currentPos = this.getMousePos(e);
                    if (!this.isDraggingLink && !this.isDragging && !this.isPanning) { const nodeOver = this.getNodeAtPos(currentPos.x, currentPos.y); const connOver = this.getHoveredConnectionId(currentPos); const connEndOver = this.getClickedConnectionEnd(currentPos); if (nodeOver || connOver || connEndOver) this.$refs.mindMapCanvas.style.cursor = 'pointer'; else this.$refs.mindMapCanvas.style.cursor = 'grab'; }
                },
                handleMouseOut(e) {
                    const canvas = this.$refs.mindMapCanvas;
                    if (canvas && !canvas.contains(e.relatedTarget)) {
                        // Clear frozen points if mouse leaves canvas during a drag
                        if (this.isDragging || this.isDraggingLink || this.draggingConnectionEnd) {
                           this.nodes.forEach(node => {
                                delete node._frozenEntryPoint;
                                delete node._frozenParentExitPointOnParent;
                            });
                        }
                        this.resetInteractionStates();
                        this.hoveredConnectionId = null;
                        this.hoveredNodeId = null;
                        if(this.$refs.mindMapCanvas) this.$refs.mindMapCanvas.style.cursor = 'grab';
                    }
                },
                handleDoubleClick(e) { if (this.isLinking || this.isDraggingLink || this.getClickedConnectionEnd(this.getMousePos(e))) return; this.hideContextMenu(); const pos = this.getMousePos(e); const clickedNode = this.getNodeAtPos(pos.x, pos.y); if (clickedNode) { this.selectedNodeId = clickedNode.id; let iconAreaXStart = clickedNode.x + 5; let clickedOnLink = false; if (clickedNode.icon) iconAreaXStart += ICON_SIZE + 5; if (clickedNode.hyperlink) { const linkIconX = iconAreaXStart; const linkIconWidth = ICON_SIZE; if (pos.x >= linkIconX && pos.x <= linkIconX + linkIconWidth && pos.y >= clickedNode.y + clickedNode.height/2 - ICON_SIZE/2 && pos.y <= clickedNode.y + clickedNode.height/2 + ICON_SIZE/2) { clickedOnLink = true; } } if (clickedOnLink) { window.open(clickedNode.hyperlink, '_blank'); return; } if (clickedNode.imageUrl) this.showImagePreview(clickedNode.imageUrl); else this.openTextEditModal(clickedNode.id); } },
                handleWheel(e) { if (this.isLinking || this.isDraggingLink) return; this.hideContextMenu(); const oldScale = this.scale; const delta = e.deltaY > 0 ? 0.9 : 1.1; this.zoom(delta, e.clientX, e.clientY); if (this.scale !== oldScale) this.recordHistory("Zoom View"); },
                zoom(factor, clientX, clientY) { const canvas = this.$refs.mindMapCanvas; if (!canvas) return; const rect = canvas.getBoundingClientRect(); const mx = clientX !== undefined ? clientX - rect.left : canvas.width / 2; const my = clientY !== undefined ? clientY - rect.top : canvas.height / 2; const wxBefore = (mx - this.offsetX) / this.scale; const wyBefore = (my - this.offsetY) / this.scale; const newScale = Math.max(0.1, Math.min(this.scale * factor, 5)); this.offsetX = mx - wxBefore * newScale; this.offsetY = my - wyBefore * newScale; this.scale = newScale; },
                resetView() { this.hideContextMenu(); const oldView = {ox: this.offsetX, oy: this.offsetY, sc: this.scale}; if (this.nodes.length > 0) { const firstNode = this.nodes.find(n => n.parentId === null) || this.nodes[0]; if (firstNode) { const canvas = this.$refs.mindMapCanvas; if (!canvas) return; const newScale = 1; this.scale = newScale; this.offsetX = canvas.width / 2 - (firstNode.x + firstNode.width / 2) * newScale; this.offsetY = canvas.height / 2 - (firstNode.y + firstNode.height / 2) * newScale; } } else { this.scale = 1; this.offsetX = 0; this.offsetY = 0; } if(oldView.ox !== this.offsetX || oldView.oy !== this.offsetY || oldView.sc !== this.scale) this.recordHistory("Reset View"); },
                handleContextMenu(e) {
                    // New logic: Close other potentially interfering UI elements first
                    if(this.fileMenu.visible) this.fileMenu.visible = false;
                    if(this.isMobileView && this.isSidebarOpen) this.isSidebarOpen = false;
                    // Ensure any existing context menu is hidden before showing a new one (hideContextMenu also clears previews)
                    this.hideContextMenu();

                    if (this.isLinking || this.isDraggingLink || this.draggingConnectionEnd) return;
                    const pos = this.getMousePos(e);
                    const clickedNode = this.getNodeAtPos(pos.x, pos.y);
                    if (clickedNode && this.selectedNodeId !== clickedNode.id) this.selectedNodeId = clickedNode.id;
                    this.contextMenu = { visible: true, x: e.clientX, y: e.clientY, nodeId: clickedNode ? clickedNode.id : null, rawX: pos.x, rawY: pos.y };
                    this.$nextTick(() => { this.adjustContextMenuPosition(); });
                },
                adjustContextMenuPosition() { const menuEl = this.$refs.contextMenuElement; if (menuEl) { const menuWidth = menuEl.offsetWidth; const menuHeight = menuEl.offsetHeight; let newX = this.contextMenu.x; let newY = this.contextMenu.y; if (newX + menuWidth > window.innerWidth) newX = window.innerWidth - menuWidth - 5; if (newY + menuHeight > window.innerHeight) newY = window.innerHeight - menuHeight - 5; if (newX < 0) newX = 5; if (newY < 0) newY = 5; this.contextMenu.x = newX; this.contextMenu.y = newY; } },
                hideContextMenu() { if (this.contextMenu.visible) this.contextMenu.visible = false; this.clearPreviewConnectionSide(); },
                handleGlobalClick(event) {
                    const contextMenuEl = this.$refs.contextMenuElement;
                    if (this.contextMenu.visible && contextMenuEl && !contextMenuEl.contains(event.target)) {
                        this.hideContextMenu();
                    }
                    const fileMenuEl = this.$refs.fileMenuElement;
                    const fileMenuButtonEl = this.$refs.fileMenuButton;
                    if (this.fileMenu.visible && fileMenuEl && !fileMenuEl.contains(event.target) &&
                        (!fileMenuButtonEl || (fileMenuButtonEl && !fileMenuButtonEl.contains(event.target))) ) {
                        this.fileMenu.visible = false;
                    }

                    // Close mobile overlay sidebar if clicking outside
                    if (this.isMobileView && this.isSidebarOpen) {
                        const mobileSidebarEl = document.getElementById('mobilePropertiesSidebar');
                        const sidebarToggleBtnEl = this.$refs.sidebarToggleButton;
                        if (mobileSidebarEl && !mobileSidebarEl.contains(event.target) &&
                            sidebarToggleBtnEl && !sidebarToggleBtnEl.contains(event.target)) {
                            this.isSidebarOpen = false;
                        }
                    }
                },
                handleGlobalKeyDown(e) {
                    if (e.key === 'Escape') {
                        let closedSomething = false;
                        // Modals first
                        if (this.isTextEditModalOpen) { this.isTextEditModalOpen = false; closedSomething = true; }
                        else if (this.isHyperlinkModalOpen) { this.isHyperlinkModalOpen = false; closedSomething = true; }
                        else if (this.isImagePreviewModalOpen) { this.isImagePreviewModalOpen = false; closedSomething = true; }
                        else if (this.isDeleteConfirmModalOpen) { this.isDeleteConfirmModalOpen = false; closedSomething = true; }
                        else if (this.isErrorModalOpen) { this.isErrorModalOpen = false; closedSomething = true; }
                        else if (this.isAboutModalOpen) { this.isAboutModalOpen = false; closedSomething = true; }
                        // Then menus / sidebars
                        else if (this.contextMenu.visible) { this.hideContextMenu(); closedSomething = true; }
                        else if (this.fileMenu.visible) { this.fileMenu.visible = false; closedSomething = true; }
                        else if (this.isSidebarOpen) { this.isSidebarOpen = false; closedSomething = true; }
                        // Then interaction states
                        else if (this.isLinking) { this.cancelLinking(); closedSomething = true; }
                        else if (this.isDraggingLink) { this.cancelDragLinking(); closedSomething = true; }

                        if (closedSomething) {
                            e.preventDefault(); // Prevent other browser escape actions if we handled it
                        }
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                        e.preventDefault(); this.undo();
                    } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                        e.preventDefault(); this.redo();
                    }
                },
                prepareSaveData() { const viewState = { offsetX: this.offsetX, offsetY: this.offsetY, scale: this.scale }; const nodesToSave = this.nodes.map(node => { const { imageObj, ...rest } = node; return rest; }); return { nodes: nodesToSave, view: viewState, canvasBgColor: this.canvasBgColor, history: this.history, currentHistoryIndex: this.currentHistoryIndex }; },
                saveMapToLocalStorage(isAutosave = false) { if (!isAutosave) { if(this.fileMenu.visible) this.fileMenu.visible = false; } try { const dataToSave = this.prepareSaveData(); localStorage.setItem('mindMapDataVue', JSON.stringify(dataToSave)); if (!isAutosave) { this.showError('Carte sauvegardée dans le navigateur !', 'success'); } else { console.log("Autosave to localStorage successful at " + new Date().toLocaleTimeString()); } } catch (error) { if (error.name === 'QuotaExceededError') { this.showError("Erreur d'auto-sauvegarde : Stockage local plein. La sauvegarde automatique est désactivée.", 'error'); if (this.autosaveIntervalId) { clearInterval(this.autosaveIntervalId); this.autosaveIntervalId = null; console.warn("Autosave stopped due to QuotaExceededError."); } } else { if (!isAutosave) { this.showError("Erreur sauvegarde locale.", 'error'); } console.error("Save to localStorage error:", error); } } },
                saveMapToFile() { if(this.fileMenu.visible) this.fileMenu.visible = false; try { const dataToSave = this.prepareSaveData(); const dataString = JSON.stringify(dataToSave, null, 2); const blob = new Blob([dataString], { type: 'application/json' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; const rootNode = this.nodes.find(n => n.parentId === null); const filename = rootNode ? `${rootNode.text.substring(0, 20).replace(/[^a-z0-9]/gi, '_')}.mapvue` : 'carte_mentale.mapvue'; link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); } catch (error) { this.showError("Erreur lors de la création du fichier .mapvue."); } },
                async processLoadedData(loadedData, from = "unknown") {
                    this.nodes.forEach(node => { if (node.imageUrl && node.imageUrl.startsWith('blob:')) URL.revokeObjectURL(node.imageUrl); });
                    this.nodes = []; this.history = []; this.currentHistoryIndex = -1; this.selectedNodeId = null;
                    let loadSuccessful = false;

                    if (!loadedData || !Array.isArray(loadedData.nodes) || !loadedData.view) {
                        console.log("No valid data found in storage or file.");
                        this.offsetX = 0; this.offsetY = 0; this.scale = 1; this.canvasBgColor = DEFAULT_CANVAS_BG_COLOR;
                        this.redrawCanvas();
                        return loadSuccessful;
                    }

                    this.offsetX = loadedData.view.offsetX || 0;
                    this.offsetY = loadedData.view.offsetY || 0;
                    this.scale = loadedData.view.scale || 1;
                    this.canvasBgColor = loadedData.canvasBgColor || DEFAULT_CANVAS_BG_COLOR;

                    let loadError = false;
                    const imageLoadPromises = loadedData.nodes.map(nodeData => {
                        return new Promise((resolve) => {
                            if (!nodeData || typeof nodeData.id === 'undefined' || nodeData.id === null) { resolve(null); return; }
                            const node = { ...nodeData, imageObj: null };
                            if (node.imageUrl && node.imageUrl.startsWith('data:image')) {
                                const img = new Image();
                                img.onload = () => { node.imageObj = img; resolve(node); };
                                img.onerror = () => { node.imageUrl = null; loadError = true; resolve(node); };
                                img.src = node.imageUrl;
                            } else {
                                node.imageUrl = null;
                                resolve(node);
                            }
                        });
                    });

                    try {
                        const resolvedNodes = await Promise.all(imageLoadPromises);
                        this.nodes = resolvedNodes.filter(Boolean);
                        if (loadError) this.showError("Certaines images n'ont pas pu être chargées.");
                        this.selectedNodeId = this.nodes.length > 0 ? (this.nodes.find(n => n.parentId === null)?.id || this.nodes[0]?.id) : null;

                        if (loadedData.history && from !== "history_navigation") {
                            this.history = loadedData.history;
                            this.currentHistoryIndex = loadedData.currentHistoryIndex !== undefined ? loadedData.currentHistoryIndex : (loadedData.history.length > 0 ? loadedData.history.length - 1 : -1);
                        } else if (from !== "history_navigation" && this.nodes.length > 0) {
                             this.recordHistory("Load Map from " + from);
                        }
                        this.redrawCanvas();
                        loadSuccessful = true;
                    } catch (error) {
                        console.error("Error processing loaded images:", error);
                        this.showError("Une erreur s'est produite lors du chargement des images de la carte.");
                        this.resetApplicationState();
                        loadSuccessful = false;
                    }
                    return loadSuccessful;
                },
                async loadMapFromLocalStorage() {
                    const savedDataString = localStorage.getItem('mindMapDataVue');
                    let loadedSuccessfully = false;
                    if (savedDataString) {
                        try {
                            const savedData = JSON.parse(savedDataString);
                            loadedSuccessfully = await this.processLoadedData(savedData, "LocalStorage");
                        } catch (error) {
                            console.error("Error parsing localStorage data:", error);
                            localStorage.removeItem('mindMapDataVue');
                            this.resetApplicationState();
                            loadedSuccessfully = false;
                        }
                    } else {
                        this.resetApplicationState();
                        loadedSuccessfully = false;
                    }
                    return loadedSuccessfully;
                },
                handleMapFileSelected(event) {
                    if(this.fileMenu.visible) this.fileMenu.visible = false;
                    const file = event.target.files[0]; if (!file) return;
                    if (!file.type.match('application/json') && !file.name.endsWith('.mapvue')) { this.showError("Veuillez sélectionner un fichier .mapvue ou .json valide."); event.target.value = ''; return; }
                    const reader = new FileReader();
                    reader.onload = async (e_reader) => {
                        try {
                            const loadedData = JSON.parse(e_reader.target.result);
                            await this.processLoadedData(loadedData, "File");
                        } catch (error) {
                            this.showError(`Erreur lors du chargement du fichier : ${error.message}`);
                            this.resetApplicationState();
                        } finally {
                            event.target.value = '';
                        }
                    };
                    reader.onerror = () => {
                        this.showError("Impossible de lire le fichier sélectionné.");
                        this.resetApplicationState();
                    }
                    reader.readAsText(file);
                },
                exportToPng() { this.hideContextMenu(); if(this.fileMenu.visible) this.fileMenu.visible = false; if (this.nodes.length === 0) { this.showError("Rien à exporter."); return;} const canvas = this.$refs.mindMapCanvas; try { const dataUrl = canvas.toDataURL('image/png'); const link = document.createElement('a'); link.href = dataUrl; const rootNode = this.nodes.find(n => n.parentId === null); const filename = rootNode ? `${rootNode.text.substring(0, 20).replace(/[^a-z0-9]/gi, '_')}.png` : 'carte-mentale.png'; link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); } catch (e) { this.showError("Erreur lors de l'exportation en PNG."); } },
                resetApplicationState() {
                    this.nodes.forEach(node => { if (node.imageUrl && node.imageUrl.startsWith('blob:')) URL.revokeObjectURL(node.imageUrl); });
                    this.nodes = [];
                    this.history = [];
                    this.currentHistoryIndex = -1;
                    this.selectedNodeId = null;
                    this.offsetX = 0;
                    this.offsetY = 0;
                    this.scale = 1;
                    this.canvasBgColor = DEFAULT_CANVAS_BG_COLOR;
                    this.previewConnectionSide = null;
                    this.hideContextMenu();
                    if(this.fileMenu) this.fileMenu.visible = false;
                    this.isErrorModalOpen = false;
                },
                resetApplication() {
                    this.resetApplicationState();
                    this.$nextTick(() => {
                        this.addInitialNode();
                        this.redrawCanvas();
                    });
                },
                getNodeIconPreview(iconClass) { if (!iconClass) return 'Aucune'; const iconObj = AVAILABLE_ICONS.find(i => i.class === iconClass); return iconObj ? iconObj.name : 'Inconnue'; },
                getNodeShapeIcon(shape) { if (shape === 'ellipse') return 'far fa-circle'; if (shape === 'diamond') return 'far fa-gem'; if (shape === 'triangle') return 'fas fa-play fa-rotate-270'; return 'far fa-square'; },
                getConnectionTypeIndicator(type) { if (type === 'solid') return '⎯'; if (type === 'dashed') return '- -'; if (type === 'arrow') return '->'; return '?'; },
                getConnectionPointCoords(node, pointName) { if (!node) return { x: 0, y: 0 }; const shape = node.shape || NODE_DEFAULT_SHAPE; const { x, y, width: w, height: h } = node; const cx = x + w / 2; const cy = y + h / 2; if (shape === 'rectangle' || shape === 'diamond') { switch (pointName) { case 'top': return { x: cx, y: y }; case 'bottom': return { x: cx, y: y + h }; case 'left': return { x: x, y: cy }; case 'right': return { x: x + w, y: cy }; default: return { x: cx, y: y }; } } else if (shape === 'ellipse') { const rx = w / 2; const ry = h / 2; if (rx <= 0 || ry <=0) return {x: cx, y: cy}; switch (pointName) { case 'top': return { x: cx, y: cy - ry }; case 'bottom': return { x: cx, y: cy + ry }; case 'left': return { x: cx - rx, y: cy }; case 'right': return { x: cx + rx, y: cy }; default: return { x: cx, y: cy - ry }; } } else if (shape === 'triangle') { switch (pointName) { case 'top': return { x: cx, y: y }; case 'bottom': return { x: cx, y: y + h }; case 'left': return { x: x + w * 0.25, y: y + h * 0.65 }; case 'right': return { x: x + w * 0.75, y: y + h * 0.65 }; default: return { x: cx, y: y }; } } return { x: cx, y: y }; },
                isAncestor(potentialChildId, potentialParentId) { let currentId = potentialParentId; let visited = new Set(); while (currentId !== null) { if (visited.has(currentId)) return true; visited.add(currentId); const node = this.findNodeById(currentId); if (!node) return false; if (node.parentId === potentialChildId) return true; currentId = node.parentId; } return false; },
                calculateDefaultConnectionPoints(parentNode, childNode) { const dx = (childNode.x + childNode.width / 2) - (parentNode.x + parentNode.width / 2); const dy = (childNode.y + childNode.height / 2) - (parentNode.y + parentNode.height / 2); if (Math.abs(dx) > Math.abs(dy)) return dx > 0 ? { parentExitPoint: 'right', entryPoint: 'left' } : { parentExitPoint: 'left', entryPoint: 'right' }; else return dy > 0 ? { parentExitPoint: 'bottom', entryPoint: 'top' } : { parentExitPoint: 'top', entryPoint: 'bottom' }; },
                getClickedConnectionEnd(pos) { const radius = CONNECTION_END_HOVER_RADIUS / this.scale; const radiusSq = radius * radius; for (const child of this.nodes) { if (child.parentId !== null) { const parent = this.findNodeById(child.parentId); if (parent) { const startCoords = this.getConnectionPointCoords(parent, child.parentExitPoint || 'bottom'); const endCoords = this.getConnectionPointCoords(child, child.entryPoint || 'top'); let dx1 = pos.x - startCoords.x; let dy1 = pos.y - startCoords.y; if (dx1 * dx1 + dy1 * dy1 <= radiusSq) return { childId: child.id, end: 'parentExit', nodeToAttach: parent }; let dx2 = pos.x - endCoords.x; let dy2 = pos.y - endCoords.y; if (dx2 * dx2 + dy2 * dy2 <= radiusSq) return { childId: child.id, end: 'childEntry', nodeToAttach: child }; } } } return null; },
                getNodeWithImageIndicatorClick(wx, wy) { for (let i = this.nodes.length - 1; i >= 0; i--) { const n = this.nodes[i]; if (!n.imageUrl || !n.imageObj) continue; const rWorld = (IMAGE_INDICATOR_SIZE / 2); const indicatorScreenX = n.x + n.width - (IMAGE_INDICATOR_SIZE / 2); const indicatorScreenY = n.y + (IMAGE_INDICATOR_SIZE / 2); const dx = wx - indicatorScreenX; const dy = wy - indicatorScreenY; if (dx * dx + dy * dy <= rWorld * rWorld) return n; } return null; },
                getHoveredConnectionId(pos) { const hoverDistThreshold = 5 / this.scale; const hoverDistThresholdSq = hoverDistThreshold * hoverDistThreshold; const numCheckPoints = 10; for (const child of this.nodes) { if (child.parentId !== null) { const parent = this.findNodeById(child.parentId); if (parent) { const startCoords = this.getConnectionPointCoords(parent, child.parentExitPoint || 'bottom'); const endCoords = this.getConnectionPointCoords(child, child.entryPoint || 'top'); const P0 = startCoords; const P3 = endCoords; let P1 = { ...P0 }, P2 = { ...P3 }; const fixedOffset = 50; switch (child.parentExitPoint || 'bottom') { case 'top': P1.y -= fixedOffset; break; case 'bottom': P1.y += fixedOffset; break; case 'left': P1.x -= fixedOffset; break; case 'right': P1.x += fixedOffset; break;} switch (child.entryPoint || 'top') { case 'top': P2.y -= fixedOffset; break; case 'bottom': P2.y += fixedOffset; break; case 'left': P2.x -= fixedOffset; break; case 'right': P2.x += fixedOffset; break;} for (let i = 1; i < numCheckPoints; i++) { const t = i / numCheckPoints; const mt = 1 - t; const x = mt*mt*mt*P0.x + 3*mt*mt*t*P1.x + 3*mt*t*t*P2.x + t*t*t*P3.x; const y = mt*mt*mt*P0.y + 3*mt*mt*t*P1.y + 3*mt*t*t*P2.y + t*t*t*P3.y; if ((pos.x - x) ** 2 + (pos.y - y) ** 2 <= hoverDistThresholdSq) return child.id; } } } } return null; }
            }
        });
        app.config.globalProperties.$filters = {
            capitalize(value) {
                if (!value) return ''
                value = value.toString()
                return value.charAt(0).toUpperCase() + value.slice(1)
            }
        }
        app.mount('#app');
    </script>
</body>
</html>
